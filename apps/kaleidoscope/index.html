<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaleidoscope v1.0.0</title>
    <style>
        :root {
            --bg-main: #0f172a;       /* Very dark blue */
            --bg-panel: #1e293b;      /* Panel background */
            --text-primary: #f1f5f9;  /* White-ish */
            --text-secondary: #94a3b8; /* Muted blue-grey */
            --accent: #3b82f6;        /* Bright Blue */
            --accent-hover: #2563eb;
            --border: #334155;
            --input-track: #475569;
            --success: #22c55e;
            --danger: #ef4444;
            --warning: #f59e0b;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: row;
            background-color: var(--bg-main);
            color: var(--text-primary);
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        /* --- SIDEBARS --- */
        .sidebar {
            width: 340px;
            background-color: var(--bg-panel);
            padding: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            z-index: 10;
            border-color: var(--border);
            flex-shrink: 0;
        }
        
        .sidebar-left { border-right: 1px solid var(--border); }
        .sidebar-right { border-left: 1px solid var(--border); }

        /* Scrollbar styling */
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-track { background: var(--bg-panel); }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

        h1 {
            margin: 0 0 15px 0;
            font-size: 20px;
            font-weight: 600;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid var(--border);
            padding-bottom: 10px;
        }
        
        h2 { 
            margin: 0 0 10px 0; 
            font-size: 16px; 
            color: var(--accent); 
            text-transform: uppercase; 
            letter-spacing: 1px;
            border-bottom: 2px solid var(--border); 
            padding-bottom: 8px; 
        }

        h3 { 
            margin: 10px 0 5px 0; 
            font-size: 13px; 
            color: var(--text-secondary); 
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            border-bottom: 1px dashed var(--border); 
            padding-bottom: 4px;
        }

        /* --- CONTROLS --- */
        .control-group { 
            background: rgba(15, 23, 42, 0.5); 
            padding: 10px; 
            border-radius: 6px; 
            border: 1px solid var(--border); 
        }

        label { 
            display: flex; 
            justify-content: space-between; 
            margin-bottom: 5px; 
            font-size: 12px; 
            color: var(--text-secondary); 
            font-weight: 500;
        }

        .value-display { 
            font-weight: bold; 
            color: var(--accent); 
            font-family: monospace;
        }

        /* --- INPUTS & SLIDERS --- */
        .input-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        button.step-btn {
            background: var(--border);
            color: var(--text-primary);
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: background 0.2s;
        }
        button.step-btn:hover { background: var(--accent); }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            margin: 0;
        }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 5px; cursor: pointer;
            background: var(--input-track); border-radius: 3px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 14px; width: 14px; border-radius: 50%;
            background: var(--accent); cursor: pointer;
            -webkit-appearance: none; margin-top: -4.5px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        select { 
            width: 100%; 
            padding: 6px; 
            background: var(--bg-main); 
            color: var(--text-primary); 
            border: 1px solid var(--border); 
            border-radius: 4px; 
            font-family: inherit; 
            cursor: pointer; 
            font-size: 12px;
        }

        .checkbox-container { display: flex; align-items: center; margin-top: 8px; gap: 8px; cursor: pointer; font-size: 12px;}
        input[type=checkbox] { width: 16px; height: 16px; accent-color: var(--accent); cursor: pointer; }

        /* --- COLOR CHANNELS --- */
        .color-channel { border-top: 1px solid var(--border); padding-top: 8px; margin-top: 8px; }
        .channel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; font-size: 12px;}
        .channel-name { font-weight: bold; width: 20px; }
        
        .anim-options { display: flex; gap: 4px; align-items: center; }
        
        .toggle-btn { 
            background: var(--bg-main); 
            border: 1px solid var(--border); 
            color: var(--text-secondary); 
            padding: 2px 6px; 
            font-size: 10px; 
            cursor: pointer; 
            border-radius: 3px; 
        }
        .toggle-btn.active { background: var(--success); color: white; border-color: var(--success); }
        
        .dir-btn { 
            background: var(--bg-main); 
            border: 1px solid var(--border); 
            color: var(--text-primary); 
            width: 20px; height: 18px; 
            font-size: 10px; 
            cursor: pointer; 
            border-radius: 3px; 
            display: flex; align-items: center; justify-content: center; 
        }

        .master-anim-controls { 
            display: flex; align-items: center; gap: 10px; margin-bottom: 10px; 
            background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; 
        }
        .play-btn { 
            background: var(--success); color: white; border: none; 
            width: 32px; height: 32px; border-radius: 50%; font-size: 14px; cursor: pointer; 
        }
        .play-btn.playing { background: var(--danger); }

        .color-preview { width: 100%; height: 24px; border-radius: 4px; margin-top: 8px; border: 1px solid var(--border); }
        
        /* --- SYSTEM BUTTONS --- */
        .sys-btn { 
            width: 100%; padding: 8px; border: none; border-radius: 4px; 
            cursor: pointer; font-weight: 600; font-size: 12px; color: white; 
            transition: opacity 0.2s; margin-top: 5px;
        }
        .sys-btn:hover { opacity: 0.9; }
        
        .btn-random { background: #8b5cf6; } /* Purple */
        .btn-save { background: var(--accent); }
        .btn-load { background: var(--success); }
        .btn-delete { background: var(--danger); }
        .btn-image { background: #0ea5e9; margin-top: auto; }
        
        .record-btn { background: var(--danger); display: flex; justify-content: center; align-items: center; gap: 8px; }
        .record-btn.recording { background: #f1f5f9; color: var(--danger); animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        .audio-btn { background: var(--warning); display: flex; justify-content: center; align-items: center; gap: 8px; color: #1e293b;}
        .audio-btn.active { background: #d97706; border: 1px solid #fff; color: white;}

        /* --- CANVAS --- */
        .main-content { 
            flex-grow: 1; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            background-color: #000; 
            padding: 20px; 
            position: relative; 
        }
        canvas { 
            background-color: #000; 
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.2); 
            image-rendering: pixelated; 
            max-width: 100%; max-height: 100%;
            border-radius: 4px;
            border: 1px solid #333;
        }
        #recStatus { 
            position: absolute; top: 30px; right: 30px; 
            color: var(--danger); font-weight: bold; display: none; 
            text-shadow: 0 0 10px rgba(0,0,0,1); pointer-events: none; 
            background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 4px;
        }

        /* Specific Slider Colors */
        #colorR::-webkit-slider-thumb { background: #ef4444; }
        #colorG::-webkit-slider-thumb { background: #22c55e; }
        #colorB::-webkit-slider-thumb { background: #3b82f6; }
        #gainR::-webkit-slider-thumb { background: #ef4444; }
        #gainG::-webkit-slider-thumb { background: #22c55e; }
        #gainB::-webkit-slider-thumb { background: #3b82f6; }
        
        .sub-group { margin-top: 10px; border-top: 1px solid var(--border); padding-top: 5px; }
        .sub-label-r { color: #ef4444; font-weight: bold; }
        .sub-label-g { color: #22c55e; font-weight: bold; }
        .sub-label-b { color: #3b82f6; font-weight: bold; }
        
        .system-btn-row { display: flex; gap: 8px; margin-top: 8px; }
        .system-btn-row .sys-btn { margin-top: 0; }

    </style>
</head>
<body>

    <!-- LEFT SIDEBAR -->
    <div class="sidebar sidebar-left">
    
        <h1>Kaleidoscope <span style="font-size:0.6em; color: var(--text-secondary)">v1.0.0</span></h1>

        <h2>Geometry</h2>
        
        <div class="control-group">
            <label>Half-Waves (n) <span id="val-wave" class="value-display">50</span></label>
            <div class="input-row">
                <button class="step-btn" onclick="adjustValue('waveCount', -0.1)">-</button>
                <input type="range" id="waveCount" min="10" max="400" value="50" step="0.1">
                <button class="step-btn" onclick="adjustValue('waveCount', 0.1)">+</button>
            </div>
        </div>

        <div class="control-group">
            <label>Offset <span id="val-offset" class="value-display">0.0000</span></label>
            <div class="input-row">
                <button class="step-btn" onclick="adjustValue('offset', -0.0001)">-</button>
                <input type="range" id="offset" min="0" max="4.0" value="0.0" step="0.0001">
                <button class="step-btn" onclick="adjustValue('offset', 0.0001)">+</button>
            </div>
        </div>

        <div class="control-group">
            <label>Bandwidth (Epsilon) <span id="val-epsilon" class="value-display">0.0050</span></label>
            <div class="input-row">
                <button class="step-btn" onclick="adjustValue('threshold', -0.0001)">-</button>
                <input type="range" id="threshold" min="0.0001" max="0.1000" value="0.0050" step="0.0001">
                <button class="step-btn" onclick="adjustValue('threshold', 0.0001)">+</button>
            </div>
        </div>

        <div class="control-group">
            <label>Sphere Diameter <span id="val-size" class="value-display">50 px</span></label>
            <div class="input-row">
                <button class="step-btn" onclick="adjustValue('sphereSize', -1)">-</button>
                <input type="range" id="sphereSize" min="6" max="200" value="50" step="1">
                <button class="step-btn" onclick="adjustValue('sphereSize', 1)">+</button>
            </div>
            
            <label style="margin-top:10px;">Intensity (Alpha) <span id="val-intensity" class="value-display">1.00</span></label>
            <div class="input-row">
                <button class="step-btn" onclick="adjustValue('sphereIntensity', -0.01)">-</button>
                <input type="range" id="sphereIntensity" min="0.1" max="1.0" step="0.01" value="1.00">
                <button class="step-btn" onclick="adjustValue('sphereIntensity', 0.01)">+</button>
            </div>
        </div>

        <h3>Post-Processing (FX)</h3>
        <div class="control-group">
            <label>Blur <span id="val-blur" class="value-display">0.0</span></label>
            <div class="input-row">
                <button class="step-btn" onclick="adjustValue('fxBlur', -0.1)">-</button>
                <input type="range" id="fxBlur" min="0" max="5" step="0.1" value="0">
                <button class="step-btn" onclick="adjustValue('fxBlur', 0.1)">+</button>
            </div>

            <label style="margin-top:5px;">Contrast <span id="val-contrast" class="value-display">1.0</span></label>
            <div class="input-row">
                <button class="step-btn" onclick="adjustValue('fxContrast', -0.05)">-</button>
                <input type="range" id="fxContrast" min="0.5" max="2.0" step="0.05" value="1.0">
                <button class="step-btn" onclick="adjustValue('fxContrast', 0.05)">+</button>
            </div>

            <label style="margin-top:5px;">Gamma <span id="val-gamma" class="value-display">1.0</span></label>
            <div class="input-row">
                <button class="step-btn" onclick="adjustValue('fxGamma', -0.05)">-</button>
                <input type="range" id="fxGamma" min="0.5" max="2.0" step="0.05" value="1.0">
                <button class="step-btn" onclick="adjustValue('fxGamma', 0.05)">+</button>
            </div>
        </div>

        <button class="sys-btn btn-image" id="saveImgBtn">Save Image (PNG)</button>
    </div>

    <!-- MAIN CANVAS -->
    <div class="main-content">
        <canvas id="canvas" width="797" height="797"></canvas>
        <div id="recStatus">‚óè RECORDING...</div>
    </div>

    <!-- RIGHT SIDEBAR -->
    <div class="sidebar sidebar-right">
        <h2>Colors & Operations</h2>
        
        <div class="control-group">
            <label>Blend Mode</label>
            <select id="blendMode">
                <option value="BGR">B‚ÜíG‚ÜíR (Standard)</option>
                <option value="RGB">R‚ÜíG‚ÜíB (Inverted)</option>
                <option value="XOR">XOR (Exclusive OR)</option>
            </select>
            <label class="checkbox-container">
                <input type="checkbox" id="negateCheck">
                <span>Invert Colors</span>
            </label>
        </div>

        <h3>Audio Matrix</h3>
        <div class="control-group">
            <button class="sys-btn audio-btn" id="btnAudioStart">üéµ Start Audio Input</button>
            
            <label style="margin-top:8px;">Master Gain <span id="val-gain" class="value-display">1.0</span></label>
            <div class="input-row">
                <button class="step-btn" onclick="adjustValue('audioGain', -0.1)">-</button>
                <input type="range" id="audioGain" min="0.1" max="2.0" step="0.1" value="1.0">
                <button class="step-btn" onclick="adjustValue('audioGain', 0.1)">+</button>
            </div>

            <!-- R CHANNEL -->
            <div class="sub-group">
                <label class="sub-label-r">Red (R) Source</label>
                <select id="srcR">
                    <option value="BASS" selected>Bass</option>
                    <option value="MID">Mid</option>
                    <option value="TREBLE">Treble</option>
                </select>
                <label>R Gain <span id="val-gainR" class="value-display">1.0</span></label>
                <div class="input-row">
                    <button class="step-btn" onclick="adjustValue('gainR', -0.1)">-</button>
                    <input type="range" id="gainR" min="0.0" max="5.0" step="0.1" value="1.0">
                    <button class="step-btn" onclick="adjustValue('gainR', 0.1)">+</button>
                </div>
            </div>

            <!-- G CHANNEL -->
            <div class="sub-group">
                <label class="sub-label-g">Green (G) Source</label>
                <select id="srcG">
                    <option value="BASS">Bass</option>
                    <option value="MID" selected>Mid</option>
                    <option value="TREBLE">Treble</option>
                </select>
                <label>G Gain <span id="val-gainG" class="value-display">1.0</span></label>
                <div class="input-row">
                    <button class="step-btn" onclick="adjustValue('gainG', -0.1)">-</button>
                    <input type="range" id="gainG" min="0.0" max="5.0" step="0.1" value="1.0">
                    <button class="step-btn" onclick="adjustValue('gainG', 0.1)">+</button>
                </div>
            </div>

            <!-- B CHANNEL -->
            <div class="sub-group">
                <label class="sub-label-b">Blue (B) Source</label>
                <select id="srcB">
                    <option value="BASS">Bass</option>
                    <option value="MID">Mid</option>
                    <option value="TREBLE" selected>Treble</option>
                </select>
                <label>B Gain <span id="val-gainB" class="value-display">1.0</span></label>
                <div class="input-row">
                    <button class="step-btn" onclick="adjustValue('gainB', -0.1)">-</button>
                    <input type="range" id="gainB" min="0.0" max="5.0" step="0.1" value="1.0">
                    <button class="step-btn" onclick="adjustValue('gainB', 0.1)">+</button>
                </div>
            </div>

            <!-- AUDIO SETTINGS -->
            <div class="sub-group">
                <label>Color Smoothing <span id="val-smoothing" class="value-display">15%</span></label>
                <div class="input-row">
                    <button class="step-btn" onclick="adjustValue('audioSmoothing', -1)">-</button>
                    <input type="range" id="audioSmoothing" min="0" max="100" step="1" value="15">
                    <button class="step-btn" onclick="adjustValue('audioSmoothing', 1)">+</button>
                </div>
                
                <label class="checkbox-container">
                    <input type="checkbox" id="audioEpsCheck">
                    <span>Epsilon Animation (Beat)</span>
                </label>
                
                <label style="margin-top:5px;">Beat Input Gain <span id="val-gainEps" class="value-display">1.0</span></label>
                <div class="input-row">
                    <button class="step-btn" onclick="adjustValue('gainEps', -0.1)">-</button>
                    <input type="range" id="gainEps" min="0.1" max="5.0" step="0.1" value="1.0">
                    <button class="step-btn" onclick="adjustValue('gainEps', 0.1)">+</button>
                </div>

                <label>Max Modulation <span id="val-epsgain" class="value-display">0.020</span></label>
                <div class="input-row">
                    <button class="step-btn" onclick="adjustValue('audioEpsGain', -0.001)">-</button>
                    <input type="range" id="audioEpsGain" min="0.000" max="0.05" step="0.001" value="0.02">
                    <button class="step-btn" onclick="adjustValue('audioEpsGain', 0.001)">+</button>
                </div>
                
                <label>Beat Smoothing <span id="val-epssmoothing" class="value-display">15%</span></label>
                <div class="input-row">
                    <button class="step-btn" onclick="adjustValue('audioEpsSmoothing', -1)">-</button>
                    <input type="range" id="audioEpsSmoothing" min="0" max="100" step="1" value="15">
                    <button class="step-btn" onclick="adjustValue('audioEpsSmoothing', 1)">+</button>
                </div>                
            </div>
        </div>

        <h3>Sphere Colors</h3>
        <div class="control-group">
            <!-- R -->
            <div class="color-channel" style="border-top:none; margin-top:0;">
                <div class="channel-header">
                    <span class="channel-name" style="color:#ef4444">R</span>
                    <div class="anim-options">
                        <button class="toggle-btn active" id="animR">Anim</button>
                        <button class="dir-btn" id="dirR">‚¨Ü</button>
                    </div>
                    <span class="channel-val" id="val-r">100</span>
                </div>
                <div class="input-row">
                    <button class="step-btn" onclick="adjustValue('colorR', -1)">-</button>
                    <input type="range" id="colorR" min="0" max="255" value="100" step="1">
                    <button class="step-btn" onclick="adjustValue('colorR', 1)">+</button>
                </div>
            </div>
            
            <!-- G -->
            <div class="color-channel">
                <div class="channel-header">
                    <span class="channel-name" style="color:#22c55e">G</span>
                    <div class="anim-options">
                        <button class="toggle-btn active" id="animG">Anim</button>
                        <button class="dir-btn" id="dirG">‚¨Ü</button>
                    </div>
                    <span class="channel-val" id="val-g">150</span>
                </div>
                <div class="input-row">
                    <button class="step-btn" onclick="adjustValue('colorG', -1)">-</button>
                    <input type="range" id="colorG" min="0" max="255" value="150" step="1">
                    <button class="step-btn" onclick="adjustValue('colorG', 1)">+</button>
                </div>
            </div>
            
            <!-- B -->
            <div class="color-channel">
                <div class="channel-header">
                    <span class="channel-name" style="color:#3b82f6">B</span>
                    <div class="anim-options">
                        <button class="toggle-btn active" id="animB">Anim</button>
                        <button class="dir-btn" id="dirB">‚¨Ü</button>
                    </div>
                    <span class="channel-val" id="val-b">200</span>
                </div>
                <div class="input-row">
                    <button class="step-btn" onclick="adjustValue('colorB', -1)">-</button>
                    <input type="range" id="colorB" min="0" max="255" value="200" step="1">
                    <button class="step-btn" onclick="adjustValue('colorB', 1)">+</button>
                </div>
            </div>

            <div class="color-preview" id="colorPreview"></div>
        </div>

        <div class="master-anim-controls">
            <button id="playBtn" class="play-btn">‚ñ∂</button>
            <div style="flex-grow:1; margin-left:10px;">
                <label>Anim. Speed</label>
                <div class="input-row">
                    <button class="step-btn" onclick="adjustValue('animSpeed', -0.1)">-</button>
                    <input type="range" id="animSpeed" min="0.1" max="5.0" step="0.1" value="1.0">
                    <button class="step-btn" onclick="adjustValue('animSpeed', 0.1)">+</button>
                </div>
            </div>
        </div>

        <h3>Background Color</h3>
        <div class="control-group">
            <div style="display:flex; align-items:center; gap:5px; margin-bottom:5px;">
                <span style="color:#ef4444; width:15px; font-weight:bold;">R</span>
                <input type="range" id="bgR" min="0" max="255" value="0">
            </div>
            <div style="display:flex; align-items:center; gap:5px; margin-bottom:5px;">
                <span style="color:#22c55e; width:15px; font-weight:bold;">G</span>
                <input type="range" id="bgG" min="0" max="255" value="0">
            </div>
            <div style="display:flex; align-items:center; gap:5px;">
                <span style="color:#3b82f6; width:15px; font-weight:bold;">B</span>
                <input type="range" id="bgB" min="0" max="255" value="0">
            </div>
            <div class="color-preview" id="bgPreview" style="height: 20px;"></div>
        </div>

        <h3>System</h3>
        <div class="control-group">
            <button class="sys-btn btn-random" id="btnRandom">üé≤ RANDOMIZE</button>
            
            <div class="sub-group">
                <label>Presets</label>
                <select id="presetSelect"><option value="">-- Select --</option></select>
                <div class="system-btn-row">
                    <button class="sys-btn btn-save" id="btnPresetSave">Save</button>
                    <button class="sys-btn btn-load" id="btnPresetLoad">Load</button>
                    <button class="sys-btn btn-delete" id="btnPresetDel">Delete</button>
                </div>
            </div>
            
            <div class="sub-group">
                <label>Video Recording (Auto Loop)</label>
                <button class="sys-btn record-btn" id="btnRecord"><span>‚óè</span> Start Recording</button>
            </div>
        </div>
    </div>

    <script>
        // --- HELPER FOR STEPPER BUTTONS ---
        window.adjustValue = function(id, change) { 
            const input = document.getElementById(id); 
            let val = parseFloat(input.value); 
            val += change; 
            
            // Fix Float Precision
            const step = parseFloat(input.step);
            if(step < 1) {
                const decimals = input.step.split('.')[1] ? input.step.split('.')[1].length : 0;
                val = parseFloat(val.toFixed(decimals));
            } else {
                val = Math.round(val);
            }

            if (val < parseFloat(input.min)) val = parseFloat(input.min); 
            if (val > parseFloat(input.max)) val = parseFloat(input.max); 
            input.value = val; 
            // Trigger input event to update canvas
            input.dispatchEvent(new Event('input'));
        };

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d', { alpha: false });

        const size = 797;
        const center = (size - 1) / 2;
        const totalPixels = size * size;
        
        const waveTable = new Float32Array(size);
        const screenBuffer = new Int32Array(totalPixels);
        const imageData = tempCtx.createImageData(size, size);
        const data32 = new Uint32Array(imageData.data.buffer); 
        const postLUT = new Uint8Array(256);

        const MAX_SPHERE_PIXELS = 40000; 
        const sphereCache = {
            offsets: new Int32Array(MAX_SPHERE_PIXELS),
            values: new Int32Array(MAX_SPHERE_PIXELS),
            dxs: new Int16Array(MAX_SPHERE_PIXELS),
            count: 0
        };

        let waveDirty = true;   
        let sphereDirty = true; 
        let prevParams = { wave: 0, diameter: 0, r: 0, g: 0, b: 0, intensity: 0, mode: '', bgR: -1, bgG: -1, bgB: -1 };

        let isPlaying = false;
        let animState = { R: { active: true, dir: 1 }, G: { active: true, dir: 1 }, B: { active: true, dir: 1 } };

        let audioCtx = null;
        let analyser = null;
        let dataArray = null;
        let isAudioActive = false;
        let audioEpsOffset = 0;

        let smoothedR = 100;
        let smoothedG = 150;
        let smoothedB = 200;
        let smoothedEpsOffset = 0;

        let isLoopRecording = false;
        let loopStartParams = null;
        let loopFrameCount = 0;

        const ui = {
            wave: document.getElementById('waveCount'), 
            offset: document.getElementById('offset'), 
            epsilon: document.getElementById('threshold'), 
            size: document.getElementById('sphereSize'), 
            intensity: document.getElementById('sphereIntensity'),
            dispSize: document.getElementById('val-size'), 
            dispIntensity: document.getElementById('val-intensity'),
            blendMode: document.getElementById('blendMode'), 
            negateCheck: document.getElementById('negateCheck'),
            bgR: document.getElementById('bgR'), 
            bgG: document.getElementById('bgG'), 
            bgB: document.getElementById('bgB'), 
            bgPreview: document.getElementById('bgPreview'),
            r: document.getElementById('colorR'), 
            g: document.getElementById('colorG'), 
            b: document.getElementById('colorB'),
            speed: document.getElementById('animSpeed'),
            fxBlur: document.getElementById('fxBlur'), 
            fxContrast: document.getElementById('fxContrast'), 
            fxGamma: document.getElementById('fxGamma'),
            
            // AUDIO UI
            btnAudio: document.getElementById('btnAudioStart'), 
            audioGain: document.getElementById('audioGain'), 
            dispGain: document.getElementById('val-gain'),
            audioSmoothing: document.getElementById('audioSmoothing'), 
            dispSmoothing: document.getElementById('val-smoothing'),
            audioEpsCheck: document.getElementById('audioEpsCheck'), 
            audioEpsGain: document.getElementById('audioEpsGain'), 
            dispEpsGain: document.getElementById('val-epsgain'),
            audioEpsSmoothing: document.getElementById('audioEpsSmoothing'), 
            dispEpsSmoothing: document.getElementById('val-epssmoothing'),
            gainEps: document.getElementById('gainEps'), 
            dispGainEps: document.getElementById('val-gainEps'),

            srcR: document.getElementById('srcR'), 
            gainR: document.getElementById('gainR'), 
            dispGainR: document.getElementById('val-gainR'),
            srcG: document.getElementById('srcG'), 
            gainG: document.getElementById('gainG'), 
            dispGainG: document.getElementById('val-gainG'),
            srcB: document.getElementById('srcB'), 
            gainB: document.getElementById('gainB'), 
            dispGainB: document.getElementById('val-gainB'),

            dispBlur: document.getElementById('val-blur'), 
            dispContrast: document.getElementById('val-contrast'), 
            dispGamma: document.getElementById('val-gamma'),
            dispWave: document.getElementById('val-wave'), 
            dispOffset: document.getElementById('val-offset'), 
            dispEps: document.getElementById('val-epsilon'), 
            dispR: document.getElementById('val-r'), 
            dispG: document.getElementById('val-g'), 
            dispB: document.getElementById('val-b'),
            preview: document.getElementById('colorPreview'), 
            playBtn: document.getElementById('playBtn')
        };

        // --- AUDIO LOGIC ---
        async function startAudio() {
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 512;
                source.connect(analyser);
                
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                isAudioActive = true;
                smoothedR = parseFloat(ui.r.value);
                smoothedG = parseFloat(ui.g.value);
                smoothedB = parseFloat(ui.b.value);
                smoothedEpsOffset = 0;
                ui.btnAudio.textContent = "üîä Audio Active";
                ui.btnAudio.classList.add('active');
                stream.getAudioTracks()[0].onended = () => { isAudioActive = false; ui.btnAudio.textContent = "üéµ Start Audio Input"; ui.btnAudio.classList.remove('active'); };
                if (!isPlaying) ui.playBtn.click();
            } catch (err) { console.error("Audio error:", err); alert("Could not access system audio. Ensure you check 'Share Audio' in the browser dialog!"); }
        }

        ui.btnAudio.addEventListener('click', startAudio);
        ui.audioGain.addEventListener('input', () => ui.dispGain.textContent = ui.audioGain.value);
        const updateGainDisplay = (id, dispId) => document.getElementById(dispId).textContent = document.getElementById(id).value;
        ui.gainR.addEventListener('input', () => updateGainDisplay('gainR', 'val-gainR'));
        ui.gainG.addEventListener('input', () => updateGainDisplay('gainG', 'val-gainG'));
        ui.gainB.addEventListener('input', () => updateGainDisplay('gainB', 'val-gainB'));        
        ui.audioSmoothing.addEventListener('input', () => ui.dispSmoothing.textContent = ui.audioSmoothing.value + '%');
        ui.audioEpsGain.addEventListener('input', () => ui.dispEpsGain.textContent = parseFloat(ui.audioEpsGain.value).toFixed(3));
        ui.audioEpsSmoothing.addEventListener('input', () => ui.dispEpsSmoothing.textContent = ui.audioEpsSmoothing.value + '%');
        ui.gainEps.addEventListener('input', () => updateGainDisplay('gainEps', 'val-gainEps'));
        ui.intensity.addEventListener('input', () => { 
             ui.dispIntensity.textContent = ui.intensity.value; 
             if (!isPlaying) requestAnimationFrame(draw); 
        });        

        function updateAudioVisuals() {
            if (!isAudioActive || !analyser) {
                audioEpsOffset = 0;
                return;
            }

            analyser.getByteFrequencyData(dataArray);
            
            let bassSum = 0, midSum = 0, highSum = 0;
            for(let i=0; i<5; i++) bassSum += dataArray[i];
            for(let i=5; i<30; i++) midSum += dataArray[i];
            for(let i=30; i<analyser.frequencyBinCount; i++) highSum += dataArray[i];

            const valBass = (bassSum / 5); 
            const valMid = (midSum / 25); 
            const valTreble = (highSum / (analyser.frequencyBinCount - 30));

            const masterGain = parseFloat(ui.audioGain.value);
            
            const getSourceVal = (sourceType) => {
                if (sourceType === 'BASS') return valBass;
                if (sourceType === 'MID') return valMid;
                if (sourceType === 'TREBLE') return valTreble;
                return 0;
            };

            let rVal = getSourceVal(ui.srcR.value) * parseFloat(ui.gainR.value) * masterGain;
            let gVal = getSourceVal(ui.srcG.value) * parseFloat(ui.gainG.value) * masterGain;
            let bVal = getSourceVal(ui.srcB.value) * parseFloat(ui.gainB.value) * masterGain;

            if (rVal > 255) rVal = 255;
            if (gVal > 255) gVal = 255;
            if (bVal > 255) bVal = 255;
            
            const smoothingPercent = parseFloat(ui.audioSmoothing.value);
            const effectivePercent = smoothingPercent / 2.0; 
            const smoothingFactor = 1.0 - (effectivePercent / 50.0) * 0.85; 
            
            smoothedR = smoothedR + (rVal - smoothedR) * smoothingFactor;
            smoothedG = smoothedG + (gVal - smoothedG) * smoothingFactor;
            smoothedB = smoothedB + (bVal - smoothedB) * smoothingFactor;

            if (smoothedR < 0) smoothedR = 0; if (smoothedR > 255) smoothedR = 255;
            if (smoothedG < 0) smoothedG = 0; if (smoothedG > 255) smoothedG = 255;
            if (smoothedB < 0) smoothedB = 0; if (smoothedB > 255) smoothedB = 255;

            ui.r.value = smoothedR;
            ui.g.value = smoothedG;
            ui.b.value = smoothedB;

            // EPSILON MODULATION
            if (ui.audioEpsCheck.checked) {
                let totalEnergy = (valBass + valMid + valTreble) / 3.0;
                const epsInputGain = parseFloat(ui.gainEps.value);
                let rawSignal = totalEnergy * epsInputGain * masterGain;
                const normalizedSignal = Math.min(1.0, Math.max(0.0, rawSignal / 255.0));
                const maxMod = parseFloat(ui.audioEpsGain.value);
                const rawEpsOffset = normalizedSignal * maxMod;
                const epsSmoothingPercent = parseFloat(ui.audioEpsSmoothing.value);
                const effectiveEpsPercent = epsSmoothingPercent / 2.0; 
                const epsSmoothingFactor = 1.0 - (effectiveEpsPercent / 50.0) * 0.85; 
                
                smoothedEpsOffset = smoothedEpsOffset + (rawEpsOffset - smoothedEpsOffset) * epsSmoothingFactor;
                audioEpsOffset = smoothedEpsOffset;
            } else {
                smoothedEpsOffset = 0;
                audioEpsOffset = 0;
            }
        }

        function updatePostLUT() {
            const contrast = parseFloat(ui.fxContrast.value);
            const gamma = parseFloat(ui.fxGamma.value);
            for (let i = 0; i < 256; i++) {
                let val = i / 255.0;
                val = Math.pow(val, 1.0 / gamma);
                val = val * 255.0;
                val = (val - 128.0) * contrast + 128.0;
                if (val < 0) val = 0; if (val > 255) val = 255;
                postLUT[i] = Math.floor(val);
            }
        }

        function precalculateSphere(diameter, r, g, b, intensity) {
            if (!sphereDirty) return;

            const radius = diameter / 2;
            const radiusSq = radius * radius;
            
            const rInt = Math.floor(r * intensity); 
            const gInt = Math.floor(g * intensity); 
            const bInt = Math.floor(b * intensity);
            
            let count = 0; 

            for (let y = 0; y < diameter; y++) {
                for (let x = 0; x < diameter; x++) {
                    const dy = y - radius; const dx = x - radius; const distSq = dx*dx + dy*dy;
                    if (distSq < radiusSq) {
                        const t = Math.sqrt(1 - (distSq / radiusSq));
                        const pixelR = Math.floor(rInt * t); 
                        const pixelG = Math.floor(gInt * t); 
                        const pixelB = Math.floor(bInt * t);
                        const packedColor = (pixelR << 16) | (pixelG << 8) | pixelB;
                        
                        if (packedColor > 0) { 
                            const dX = Math.floor(dx);
                            sphereCache.offsets[count] = Math.floor(dy) * size + dX;
                            sphereCache.values[count] = packedColor;
                            sphereCache.dxs[count] = dX;
                            count++;
                        }
                    }
                }
            }
            sphereCache.count = count; 
            sphereDirty = false;
        }

        function draw() {
            const n = parseFloat(ui.wave.value);
            const offset = parseFloat(ui.offset.value);
            const epsilon = parseFloat(ui.epsilon.value) + audioEpsOffset;

            const diameter = parseInt(ui.size.value);
            const intensity = parseFloat(ui.intensity.value);
            const r = parseFloat(ui.r.value); 
            const g = parseFloat(ui.g.value); 
            const b = parseFloat(ui.b.value);
            const bgR = parseInt(ui.bgR.value); 
            const bgG = parseInt(ui.bgG.value); 
            const bgB = parseInt(ui.bgB.value);
            const blurVal = parseFloat(ui.fxBlur.value);
            const contrastVal = parseFloat(ui.fxContrast.value);
            const gammaVal = parseFloat(ui.fxGamma.value);

            const mode = ui.blendMode.value;
            const negate = ui.negateCheck.checked;

            if (n !== prevParams.wave) { 
                waveDirty = true; 
                prevParams.wave = n; 
            }            

            ui.dispWave.textContent = n; ui.dispOffset.textContent = offset.toFixed(4); ui.dispEps.textContent = epsilon.toFixed(4); ui.dispSize.textContent = diameter + " px";
            ui.dispR.textContent = Math.floor(r); ui.dispG.textContent = Math.floor(g); ui.dispB.textContent = Math.floor(b);
            ui.dispBlur.textContent = blurVal.toFixed(1); ui.dispContrast.textContent = contrastVal.toFixed(2); ui.dispGamma.textContent = gammaVal.toFixed(2);
            
            ui.preview.style.setProperty('--bg-color', `rgb(${r},${g},${b})`);
            ui.bgPreview.style.backgroundColor = `rgb(${bgR},${bgG},${bgB})`;

            updatePostLUT();
            
            let mapR, mapG, mapB; 
            let inR, inG, inB;    
            let inBgR, inBgG, inBgB;

            if (mode === 'RGB') {
                inR=b; inG=g; inB=r;     
                inBgR=bgB; inBgG=bgG; inBgB=bgR;
                mapR=0; mapG=8; mapB=16; 
            } else {
                inR=r; inG=g; inB=b;     
                inBgR=bgR; inBgG=bgG; inBgB=bgB;
                mapR=16; mapG=8; mapB=0; 
            }

            if (diameter !== prevParams.diameter || 
                inR !== prevParams.r || inG !== prevParams.g || inB !== prevParams.b || 
                intensity !== prevParams.intensity) {
                
                sphereDirty = true;
                prevParams.diameter = diameter;
                prevParams.r = inR; prevParams.g = inG; prevParams.b = inB;
                prevParams.intensity = intensity;
            }

            precalculateSphere(diameter, inR, inG, inB, intensity);

            const packedBg = (inBgR << 16) | (inBgG << 8) | inBgB;
            screenBuffer.fill(packedBg);

            const upperLimit = 2.0 - offset + epsilon / 2; 
			const lowerLimit = 2.0 - offset - epsilon / 2;

            if (waveDirty) {
                for (let i = 0; i < size; i++) {
                    const relativePos = (i - center) / center; 
                    waveTable[i] = Math.cos(relativePos * (n * Math.PI / 2));
                }
                waveDirty = false;
            }

            const sphereOffsets = sphereCache.offsets; 
            const sphereValues = sphereCache.values; 
            const sphereDxs = sphereCache.dxs; 
            const sphereLen = sphereCache.count; 

            if (mode !== 'XOR') {
                if (negate) {
                    for (let y = 0; y < size; y++) {
                        const valY = waveTable[y]; if (valY < lowerLimit - 1.0) continue; const rowOffset = y * size;
                        for (let x = 0; x < size; x++) {
                            const sum = valY + waveTable[x];
                            if (sum >= lowerLimit && sum <= upperLimit) {
                                const centerIdx = rowOffset + x;
                                for (let k = 0; k < sphereLen; k++) {
                                    const targetX = x + sphereDxs[k];
                                    if (targetX >= 0 && targetX < size) {
                                        const tIdx = centerIdx + sphereOffsets[k];
                                        if (tIdx >= 0 && tIdx < totalPixels) {
                                            let sphereVal = (~sphereValues[k]) & 0xFFFFFF;
                                            let sum = screenBuffer[tIdx] + sphereVal;
                                            if (sum > 0xFFFFFF) {
                                                sum = (sum & 0xFFFFFF) + 1;
                                            }
                                            screenBuffer[tIdx] = sum;
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    for (let y = 0; y < size; y++) {
                        const valY = waveTable[y]; if (valY < lowerLimit - 1.0) continue; const rowOffset = y * size;
                        for (let x = 0; x < size; x++) {
                            const sum = valY + waveTable[x];
                            if (sum >= lowerLimit && sum <= upperLimit) {
                                const centerIdx = rowOffset + x;
                                for (let k = 0; k < sphereLen; k++) {
                                    const targetX = x + sphereDxs[k];
                                    if (targetX >= 0 && targetX < size) {
                                        const tIdx = centerIdx + sphereOffsets[k];
                                        if (tIdx >= 0 && tIdx < totalPixels) {
                                            let res = screenBuffer[tIdx] + sphereValues[k];
                                            if (res > 0xFFFFFF) {
                                                res = (res & 0xFFFFFF) + 1;
                                            }
                                            screenBuffer[tIdx] = res;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (mode === 'XOR') {
                for (let y = 0; y < size; y++) {
                    const valY = waveTable[y]; if (valY < lowerLimit - 1.0) continue; const rowOffset = y * size;
                    for (let x = 0; x < size; x++) {
                        const sum = valY + waveTable[x];
                        if (sum >= lowerLimit && sum <= upperLimit) {
                            const centerIdx = rowOffset + x;
                            for (let k = 0; k < sphereLen; k++) {
                                const targetX = x + sphereDxs[k];
                                if (targetX >= 0 && targetX < size) {
                                    const tIdx = centerIdx + sphereOffsets[k];
                                    if (tIdx >= 0 && tIdx < totalPixels) {
                                        let res = screenBuffer[tIdx] ^ sphereValues[k];
                                        if (negate) res = (~res) & 0xFFFFFF;
                                        screenBuffer[tIdx] = res;
                                    }
                                }    
                            }
                        }
                    }
                }
            }

            for (let i = 0; i < totalPixels; i++) {
                const val = screenBuffer[i];
                
                const rRaw = (val >> mapR) & 0xFF; 
                const gRaw = (val >> mapG) & 0xFF; 
                const bRaw = (val >> mapB) & 0xFF;
                
                const R = postLUT[rRaw]; 
                const G = postLUT[gRaw]; 
                const B = postLUT[bRaw];
                
                data32[i] = (255 << 24) | (B << 16) | (G << 8) | R;
            }

            tempCtx.putImageData(imageData, 0, 0);
            ctx.filter = `blur(${blurVal}px)`;
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.filter = 'none';
        }

        function animateLoop() {
            if (!isPlaying) return;
            
            if (isAudioActive) {
                updateAudioVisuals();
            } else {
                const speed = parseFloat(ui.speed.value);
                const updateChannel = (channelKey, inputElem, btnId) => {
                    if (animState[channelKey].active) {
                        let val = parseFloat(inputElem.value);
                        let dir = animState[channelKey].dir;
                        val += speed * dir;
                        if (val >= 255) { val = 255; dir = -1; animState[channelKey].dir = -1; document.getElementById(btnId).textContent = "‚¨á"; } 
                        else if (val <= 0) { val = 0; dir = 1; animState[channelKey].dir = 1; document.getElementById(btnId).textContent = "‚¨Ü"; }
                        inputElem.value = val;
                    }
                };
                updateChannel('R', ui.r, 'dirR'); 
                updateChannel('G', ui.g, 'dirG'); 
                updateChannel('B', ui.b, 'dirB');
            }
            
            draw();

            if (isLoopRecording && !isAudioActive) {
                loopFrameCount++;
                if (loopFrameCount > 60) {
                    let allMatch = true;
                    const tolerance = parseFloat(ui.speed.value) * 1.5; 
                    if (loopStartParams.R) { const diff = Math.abs(parseFloat(ui.r.value) - loopStartParams.R.val); if (diff > tolerance || animState.R.dir !== loopStartParams.R.dir) allMatch = false; }
                    if (loopStartParams.G) { const diff = Math.abs(parseFloat(ui.g.value) - loopStartParams.G.val); if (diff > tolerance || animState.G.dir !== loopStartParams.G.dir) allMatch = false; }
                    if (loopStartParams.B) { const diff = Math.abs(parseFloat(ui.b.value) - loopStartParams.B.val); if (diff > tolerance || animState.B.dir !== loopStartParams.B.dir) allMatch = false; }
                    if (allMatch) stopRecording();
                }
            }

            requestAnimationFrame(animateLoop);
        }
        
        let mediaRecorder; let recordedChunks = [];
        const btnRecord = document.getElementById('btnRecord'); const recStatus = document.getElementById('recStatus');
        
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop(); isLoopRecording = false; btnRecord.innerHTML = "<span>‚óè</span> Start Recording"; btnRecord.classList.remove('recording'); recStatus.style.display = 'none';
            }
        }

        btnRecord.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') { stopRecording(); } 
            else {
                const stream = canvas.captureStream(60);
                const types = [{ mime: 'video/mp4;codecs=avc1.4d002a', ext: 'mp4', bitrate: 15000000 }, { mime: 'video/mp4', ext: 'mp4', bitrate: 15000000 }, { mime: 'video/webm;codecs=vp9', ext: 'webm', bitrate: 15000000 }, { mime: 'video/webm', ext: 'webm', bitrate: 15000000 }];
                let selectedType = null; for (const t of types) { if (MediaRecorder.isTypeSupported(t.mime)) { selectedType = t; break; } }
                if (!selectedType) { alert("Format not supported."); return; }
                try { mediaRecorder = new MediaRecorder(stream, { mimeType: selectedType.mime, videoBitsPerSecond: selectedType.bitrate }); } 
                catch (e) { mediaRecorder = new MediaRecorder(stream); selectedType = { ext: 'webm' }; }
                recordedChunks = []; mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: selectedType.mime || 'video/webm' }); const url = URL.createObjectURL(blob);
                    const now = new Date(); const pad = (n) => n.toString().padStart(2, '0');
                    const filename = `VID_${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}.${selectedType.ext}`;
                    const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url);
                };
                isLoopRecording = true; loopFrameCount = 0;
                loopStartParams = { R: animState.R.active ? { val: parseFloat(ui.r.value), dir: animState.R.dir } : null, G: animState.G.active ? { val: parseFloat(ui.g.value), dir: animState.G.dir } : null, B: animState.B.active ? { val: parseFloat(ui.b.value), dir: animState.B.dir } : null };
                if (!loopStartParams.R && !loopStartParams.G && !loopStartParams.B) isLoopRecording = false;
                mediaRecorder.start(); btnRecord.textContent = "‚ñ† Stop Recording"; btnRecord.classList.add('recording'); recStatus.textContent = `‚óè RECORDING (${selectedType.ext.toUpperCase()})...`; recStatus.style.display = 'block';
            }
        });

        ui.playBtn.addEventListener('click', () => { isPlaying = !isPlaying; if (isPlaying) { ui.playBtn.textContent = "‚ñ†"; ui.playBtn.classList.add('playing'); animateLoop(); } else { ui.playBtn.textContent = "‚ñ∂"; ui.playBtn.classList.remove('playing'); } });
        function toggleAnim(channel, btnId) { animState[channel].active = !animState[channel].active; const btn = document.getElementById(btnId); if (animState[channel].active) btn.classList.add('active'); else btn.classList.remove('active'); }
        document.getElementById('animR').addEventListener('click', () => toggleAnim('R', 'animR')); document.getElementById('animG').addEventListener('click', () => toggleAnim('G', 'animG')); document.getElementById('animB').addEventListener('click', () => toggleAnim('B', 'animB'));
        function toggleDir(channel, btnId) { animState[channel].dir *= -1; const btn = document.getElementById(btnId); btn.textContent = animState[channel].dir === 1 ? "‚¨Ü" : "‚¨á"; }
        document.getElementById('dirR').addEventListener('click', () => toggleDir('R', 'dirR')); document.getElementById('dirG').addEventListener('click', () => toggleDir('G', 'dirG')); document.getElementById('dirB').addEventListener('click', () => toggleDir('B', 'dirB'));
        ui.blendMode.addEventListener('change', draw); ui.negateCheck.addEventListener('change', draw);
        ui.bgR.addEventListener('input', () => requestAnimationFrame(draw)); ui.bgG.addEventListener('input', () => requestAnimationFrame(draw)); ui.bgB.addEventListener('input', () => requestAnimationFrame(draw));
        ui.fxBlur.addEventListener('input', () => { if(!isPlaying) requestAnimationFrame(draw); }); ui.fxContrast.addEventListener('input', () => { if(!isPlaying) requestAnimationFrame(draw); }); ui.fxGamma.addEventListener('input', () => { if(!isPlaying) requestAnimationFrame(draw); });
        document.getElementById('saveImgBtn').addEventListener('click', () => { const now = new Date(); const pad = (n) => n.toString().padStart(2, '0'); const filename = `IMG_${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}.png`; const link = document.createElement('a'); link.download = filename; link.href = canvas.toDataURL('image/png'); link.click(); });
        document.querySelectorAll('input[type=range]').forEach(input => { input.addEventListener('input', () => { if (!isPlaying) requestAnimationFrame(draw); }); });
        
        document.getElementById('btnRandom').addEventListener('click', () => { 
            ui.wave.value = Math.floor(Math.random()*130)+20; ui.offset.value = Math.random()*3.5; ui.epsilon.value = (Math.random()*0.02)+0.001; ui.size.value = Math.floor(Math.random()*100)+50; ui.r.value = Math.floor(Math.random()*255); ui.g.value = Math.floor(Math.random()*255); ui.b.value = Math.floor(Math.random()*255); 
            if(Math.random()>0.7){ ui.bgR.value=Math.floor(Math.random()*50); ui.bgG.value=Math.floor(Math.random()*50); ui.bgB.value=Math.floor(Math.random()*50); } else { ui.bgR.value=0; ui.bgG.value=0; ui.bgB.value=0; } 
            ui.blendMode.value = ['BGR','XOR'][Math.floor(Math.random()*2)]; ui.negateCheck.checked = Math.random()>0.7; draw(); 
        });

        const presetSelect = document.getElementById('presetSelect');
        function getSettings() { return { wave: ui.wave.value, offset: ui.offset.value, epsilon: ui.epsilon.value, size: ui.size.value, r: ui.r.value, g: ui.g.value, b: ui.b.value, bgR: ui.bgR.value, bgG: ui.bgG.value, bgB: ui.bgB.value, mode: ui.blendMode.value, negate: ui.negateCheck.checked, fxBlur: ui.fxBlur.value, fxContrast: ui.fxContrast.value, fxGamma: ui.fxGamma.value }; }
        function applySettings(s) { ui.wave.value = s.wave; ui.offset.value = s.offset; ui.epsilon.value = s.epsilon; ui.size.value = s.size; ui.r.value = s.r; ui.g.value = s.g; ui.b.value = s.b; ui.bgR.value = s.bgR||0; ui.bgG.value = s.bgG||0; ui.bgB.value = s.bgB||0; ui.blendMode.value = s.mode; ui.negateCheck.checked = s.negate; ui.fxBlur.value = s.fxBlur||0; ui.fxContrast.value = s.fxContrast||1; ui.fxGamma.value = s.fxGamma||1; draw(); }
        
        function refreshPresetList() { 
            presetSelect.innerHTML = '<option value="">-- Select --</option>'; 
            const factory = [
                {name:"Christmas",data:{wave:30,offset:0.8,epsilon:0.005,size:25,r:0,g:255,b:100,mode:"BGR",negate:false}},
                {name:"Soft Glow",data:{wave:40,offset:0.5,epsilon:0.01,size:20,r:200,g:100,b:255,mode:"BGR",negate:false,fxBlur:2.5,fxContrast:1.2}}
            ]; 
            factory.forEach((p,idx)=>{const opt=document.createElement('option');opt.value="FACTORY_"+idx;opt.textContent="‚òÖ "+p.name;presetSelect.appendChild(opt);}); 
            for(let i=0;i<localStorage.length;i++){const key=localStorage.key(i);if(key.startsWith("INTERF_PRESET_")){const opt=document.createElement('option');opt.value=key;opt.textContent=key.replace("INTERF_PRESET_","");presetSelect.appendChild(opt);}} 
        }
        
        document.getElementById('btnPresetSave').addEventListener('click', () => { const name = prompt("Name of preset?"); if(name) { localStorage.setItem("INTERF_PRESET_"+name, JSON.stringify(getSettings())); refreshPresetList(); }});
        document.getElementById('btnPresetLoad').addEventListener('click', () => { const val = presetSelect.value; if(!val) return; if(val.startsWith("FACTORY_")){ const idx = parseInt(val.split("_")[1]); const factory = [{wave:30,offset:0.8,epsilon:0.005,size:25,r:0,g:255,b:100,mode:"BGR",negate:false},{wave:40,offset:0.5,epsilon:0.01,size:20,r:200,g:100,b:255,mode:"BGR",negate:false,fxBlur:2.5,fxContrast:1.2}]; applySettings(factory[idx]); } else { const data = JSON.parse(localStorage.getItem(val)); if(data) applySettings(data); } });
        document.getElementById('btnPresetDel').addEventListener('click', () => { const val = presetSelect.value; if(val && !val.startsWith("FACTORY_")) { if(confirm("Delete this preset?")) { localStorage.removeItem(val); refreshPresetList(); } } });

        refreshPresetList();
        draw(); 
    </script>
</body>
</html>
