<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ulam Laborat√≥rium v1.5.0</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #eee;
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            justify-content: center;
            padding: 10px;
            margin: 0;
            min-height: 100vh;
            box-sizing: border-box;
            height: 100vh;
            overflow: hidden;
        }
        
        .controls {
            position: fixed; /* Changed to fixed for sidebar toggle */
            left: 0; top: 0; bottom: 0;
            z-index: 100;
            background: #2d2d2d;
            padding: 0; /* Reset padding for sections */
            display: flex;
            flex-direction: column;
            width: 300px;
            box-shadow: 4px 0 15px rgba(0,0,0,0.5);
            border-right: 1px solid #444;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }
        .controls.hidden { transform: translateX(-100%); }
        
        .sidebar-toggle {
            position: fixed;
            top: 10px; left: 10px;
            z-index: 200;
            background: #2d2d2d;
            color: #eee;
            border: 1px solid #444;
            border-radius: 4px;
            width: 32px; height: 32px;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: left 0.3s ease;
        }
        .controls:not(.hidden) + .sidebar-toggle { left: 310px; } /* Move button when sidebar is open */

        /* Accordion Styles */
        .control-section { border-bottom: 1px solid #444; }
        .section-header {
            padding: 12px 15px;
            background: #333;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.85rem;
            color: #eee;
            display: flex; justify-content: space-between; align-items: center;
            user-select: none;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .section-header:hover { background: #3a3a3a; }
        .section-content {
            padding: 15px;
            display: flex; flex-direction: column; gap: 10px;
            background: #262626;
        }
        .section-content.collapsed { display: none; }
        .arrow { transition: transform 0.2s; font-size: 0.7rem; }
        .section-content.collapsed + .arrow { transform: rotate(-90deg); } /* Logic handled in JS mostly */

        .control-group { display: flex; flex-direction: column; margin-bottom: 5px; }
        label { font-size: 0.75rem; margin-bottom: 4px; color: #bbb; text-transform: uppercase; letter-spacing: 0.5px; font-weight: bold; }
        input[type="number"], select { background: #3a3a3a; border: 1px solid #555; color: white; padding: 6px; border-radius: 4px; font-size: 0.9rem; }
        input[type="number"]:focus, select:focus { outline: none; border-color: #007bff; }

        .info-panel {
            background: #222;
            border: 1px solid #007bff;
            padding: 10px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9rem;
            color: #00ffaa;
            height: 110px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            gap: 5px;
        }
        .info-row { display: flex; justify-content: space-between; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .info-label { color: #888; }
        .info-val { font-weight: bold; color: white; }
        .info-big { font-size: 1.2rem; color: #ffcc00; text-align: center; margin-top: auto; padding-top: 5px; }

        .mode-selector { display: flex; flex-direction: column; gap: 6px; background: #222; padding: 8px; border-radius: 6px; border: 1px solid #444; }
        .mode-selector label { margin: 0; cursor: pointer; color: #ddd; font-weight: normal; display: flex; align-items: center; gap: 8px; text-transform: none; font-size: 0.85rem; padding: 2px; }
        .mode-selector label:hover { background: #333; }

        .add-layer-group { display: flex; gap: 5px; align-items: center; }
        input[type="color"] { background: none; border: none; width: 40px; height: 36px; cursor: pointer; padding: 0; }
        .main-action-btn { 
            background: linear-gradient(to bottom, #007bff, #0069d9); 
            color: white; border: 1px solid #0056b3; 
            padding: 8px; border-radius: 4px; cursor: pointer; 
            font-weight: bold; flex-grow: 1; font-size: 0.8rem; text-transform: uppercase; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .main-action-btn:hover { background: linear-gradient(to bottom, #0069d9, #0056b3); }
        
        .layer-list { display: flex; flex-direction: column; gap: 5px; font-size: 0.8rem; margin-top: 0; min-height: 50px; max-height: 250px; overflow-y: auto; padding-right: 5px; }
        .layer-list::-webkit-scrollbar { width: 6px; }
        .layer-list::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }
        .layer-item { background: #333; padding: 6px 8px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; border-left: 4px solid transparent; flex-shrink: 0; }
        .layer-item.hidden-layer { opacity: 0.5; background: #252525; }
        .layer-info { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; display: flex; align-items: center; flex: 1; min-width: 0; }
        .layer-controls { display: flex; gap: 4px; }
        .icon-btn { background: #444; border: 1px solid #555; color: #eee; width: 24px; height: 24px; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; }
        .icon-btn:hover { background: #555; }
        .btn-delete:hover { background: #602020; border-color: #ff4444; }

        .canvas-container { 
            background-color: #000; 
            box-shadow: inset 0 0 50px rgba(0,0,0,0.8); 
            overflow: hidden; 
            flex-grow: 1; 
            display: block; 
            position: relative; 
            height: 100%; 
            margin-left: 300px; /* Offset for sidebar */
            transition: margin-left 0.3s ease;
        }
        .controls.hidden ~ .canvas-container { margin-left: 0; }
        canvas { display: block; image-rendering: pixelated; transform-origin: 0 0; }

        /* Canvas Overlay Controls */
        .canvas-controls {
            position: absolute;
            bottom: 20px; right: 20px;
            display: flex; gap: 5px;
            z-index: 50;
        }
        .canvas-btn {
            width: 36px; height: 36px;
            background: rgba(40, 40, 40, 0.8);
            border: 1px solid #555;
            border-radius: 50%;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .canvas-btn:hover { background: rgba(60, 60, 60, 0.9); transform: scale(1.1); }

        .gol-controls { display: flex; gap: 5px; margin-top: 8px; }
        .gol-btn { flex: 1; padding: 8px; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 0.8rem; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .gol-btn:active { transform: translateY(1px); box-shadow: none; }
        
        .secondary-btn { background: #555; color: white; border: none; padding: 8px; width: 100%; margin-top: 5px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: background 0.2s; }
        .secondary-btn:hover { background: #666; }
        .delete-all-btn { background: #a72828; }
        .delete-all-btn:hover { background: #c53030; }

        .helper-text { font-size: 0.7rem; color: #888; margin-top: 5px; font-style: italic; text-align: center; }

        .bit-selector {
            display: flex;
            justify-content: space-between;
            background: #222;
            padding: 2px;
            border-radius: 4px;
        }
        .bit-chk {
            display: none; /* Rejtett checkbox */
        }
        .bit-label {
            flex: 1;
            text-align: center;
            cursor: pointer;
            padding: 4px 0;
            font-size: 0.8rem;
            color: #666;
            user-select: none;
            transition: all 0.2s;
            border-radius: 2px;
        }
        .bit-label:hover { background: #444; }
        /* Ha be van pip√°lva a rejtett checkbox, a label st√≠lusa v√°ltozik */
        .bit-chk:checked + .bit-label {
            background: #007bff;
            color: white;
            font-weight: bold;
        }
        /* K√ºl√∂n sz√≠n a Survive-nak, hogy ne keverj√ºk √∂ssze */
        #surviveSelector .bit-chk:checked + .bit-label {
            background: #28a745;
        }

    </style>
</head>
<body>

    <button class="sidebar-toggle" onclick="toggleSidebar()" title="Vez√©rl≈ëpanel elrejt√©se/megjelen√≠t√©se">
        <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none"><path d="M3 12h18M3 6h18M3 18h18"/></svg>
    </button>

    <div class="controls" id="sidebar">
        
        <div style="padding: 15px; border-bottom: 1px solid #444; background: #252525;">
            <h2 style="margin: 0; font-size: 1.2rem; color: #fff;">Ulam Laborat√≥rium <small style="font-size: 0.8rem; color: #888;">v1.5.0</small></h2>
        </div>

        <!-- SECTION 1: KURZOR & INF√ì -->
        <div class="control-section">
            <div class="section-header" onclick="toggleSection(this)">Kurzor & Inf√≥ <span class="arrow">‚ñº</span></div>
            <div class="section-content">
                <div class="info-panel" id="statusPanel">
                    <div class="info-row"><span class="info-label">Poz√≠ci√≥:</span> <span class="info-val" id="infoPos">-</span></div>
                    <div class="info-row"><span class="info-label">Index:</span> <span class="info-val" id="infoIdx">-</span></div>
                    <div style="font-size:0.75rem; color:#888; margin-top:5px;">Sz√°m√©rt√©k (Szekvencia):</div>
                    <div class="info-big" id="infoVal">-</div>
                </div>
            </div>
        </div>

        <!-- SECTION 2: ULAM PARAM√âTEREK -->
        <div class="control-section">
            <div class="section-header" onclick="toggleSection(this)">Ulam Param√©terek <span class="arrow">‚ñº</span></div>
            <div class="section-content">
                <div class="control-group">
                    <label for="startValue">Kezd≈ë√©rt√©k</label>
                    <input type="number" id="startValue" value="0" min="0" oninput="drawSpiral()">
                </div>
                <div class="control-group">
                    <label for="increment">N√∂vekm√©ny</label>
                    <input type="number" id="increment" value="1" min="1" oninput="drawSpiral()">
                </div>
                
                <div class="mode-selector">
                    <label><input type="radio" name="ulamMode" value="prime" checked onchange="drawSpiral()"> Pr√≠m</label>
                    <label><input type="radio" name="ulamMode" value="square" onchange="drawSpiral()"> N√©gyzet</label>
                    <label><input type="radio" name="ulamMode" value="cube" onchange="drawSpiral()"> K√∂b</label>
                    <label><input type="radio" name="ulamMode" value="step" onchange="drawSpiral()"> Szekvencia</label>
                    <label><input type="radio" name="ulamMode" value="empty" onchange="drawSpiral()"> √úres (Csak k√∂z√©ppont)</label>
                </div>
            </div>
        </div>

        <!-- SECTION 3: R√âTEGEK -->
        <div class="control-section">
            <div class="section-header" onclick="toggleSection(this)">R√©tegek <span class="arrow">‚ñº</span></div>
            <div class="section-content">
                <label>√öj r√©teg hozz√°ad√°sa / Sz√≠n</label>
                <div class="add-layer-group">
                    <input type="color" id="layerColor" value="#ffff00" title="V√°lassz sz√≠nt" oninput="onColorChange()">
                    <button class="main-action-btn" onclick="addLayer()">+ Hozz√°ad√°s</button>
                </div>
                <div class="layer-list" id="layerList"></div>
            </div>
        </div>

        <!-- SECTION 4: √âLETJ√ÅT√âK -->
        <div class="control-section">
            <div class="section-header" onclick="toggleSection(this)">√âletj√°t√©k <span class="arrow">‚ñº</span></div>
            <div class="section-content">
                <label>Szab√°lyok</label>
                <select id="lifeRule" onchange="toggleRuleEditor()">
                    <option value="life" selected>Game of Life (B3/S23)</option>
                    <option value="highlife">HighLife (B36/S23)</option>
                    <option value="daynight">Day & Night (B3678/S34678)</option>
                    <option value="seeds">Seeds (B2/S)</option>
                    <option value="diamoeba">Diamoeba (B35678/S5678)</option>
                    <option value="morley">Morley (B368/S245)</option>
                    <option value="replicator">Replicator (B1357/S1357)</option>
                    <option value="walledcities">Walled Cities (B45678/S2345)</option>
                    <option value="stains">Stains (B3678/S235678)</option>
                    <option value="maze">Maze (B3/S12345)</option>
                    <option value="anneal">Anneal (B4678/S35678)</option>
                    <option value="custom" style="font-weight:bold; color:#ffcc00;">üõ†Ô∏è Egy√©ni Szab√°ly...</option>
                </select>

                <!-- EGY√âNI SZAB√ÅLY SZERKESZT≈ê (Alapb√≥l rejtve) -->
                <div id="customRuleEditor" style="display:none; background:#333; padding:8px; border-radius:4px; margin-top:5px; border:1px solid #555;">
                    <div style="font-size:0.75rem; color:#bbb; margin-bottom:4px;">SZ√úLET√âS (Born): H√°ny szomsz√©dn√°l?</div>
                    <div class="bit-selector" id="bornSelector"></div>
                    <div style="font-size:0.75rem; color:#bbb; margin:6px 0 4px 0;">T√öL√âL√âS (Survive): H√°ny szomsz√©dn√°l?</div>
                    <div class="bit-selector" id="surviveSelector"></div>
                    <div id="ruleNameDisplay" style="text-align:center; font-size:0.8rem; color:#00ffaa; margin-top:5px;">B3/S23</div>
                </div>            
                
                <div style="margin-top:8px; border-top:1px solid #444; padding-top:8px;">
                    <label>Sz√≠nez√©si M√≥d</label>
                    <select id="colorMode" onchange="onColorModeChange()">
                        <option value="static">Statikus (Alap)</option>
                        <option value="trail">Ut√≥h√∫z√°s (Trail)</option>
                        <option value="age">√âletkor (Age)</option>
                    </select>
                </div>

                <div class="gol-controls">
                    <button class="gol-btn" id="btnStart" onclick="toggleLife()" style="background: #28a745;">Start</button>
                    <button class="gol-btn" onclick="resetLife()" style="background: #17a2b8;">Reset</button>
                </div>
                <button class="gol-btn" onclick="clearScreen()" style="background: #d63384; margin-top:5px; width:100%;">T√∂rl√©s (Clear)</button>
            </div>
        </div>

        <!-- SECTION 5: M≈∞VELETEK & PROJEKT -->
        <div class="control-section">
            <div class="section-header" onclick="toggleSection(this)">M≈±veletek <span class="arrow">‚ñº</span></div>
            <div class="section-content">
                <div class="stats">Pixel db: <span id="matchCount">0</span></div>
                <div class="helper-text" style="margin-bottom:10px;">SHIFT + Klikk: Pixel invert√°l√°sa</div>
                
                <button class="secondary-btn delete-all-btn" onclick="deleteAllLayers()">Minden t√∂rl√©se</button>
                <button class="secondary-btn" onclick="saveImage()">K√©p ment√©se (PNG)</button>
                
                <div style="margin-top:15px; border-top:1px solid #444; padding-top:10px;">
                    <label>Projekt Ment√©s / Bet√∂lt√©s</label>
                    <button class="secondary-btn" onclick="exportConfig()" style="background:#555; margin-bottom:5px;">Ment√©s F√°jlba (JSON)</button>
                    <button class="secondary-btn" onclick="document.getElementById('fileInput').click()" style="background:#555;">Bet√∂lt√©s F√°jlb√≥l</button>
                    <input type="file" id="fileInput" style="display:none" onchange="importConfig(this)" accept=".json">
                </div>
            </div>
        </div>

    </div>

    <div class="canvas-container">
        <canvas id="ulamCanvas" width="1001" height="1001"></canvas>
        <div class="canvas-controls">
            <button class="canvas-btn" onclick="zoomCanvas(1.2)" title="Nagy√≠t√°s">+</button>
            <button class="canvas-btn" onclick="zoomCanvas(0.8)" title="Kicsiny√≠t√©s">-</button>
            <button class="canvas-btn" onclick="fitToScreen()" title="K√©perny≈ëre igaz√≠t√°s">‚ü≤</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('ulamCanvas');
        const container = document.querySelector('.canvas-container');
        const ctx = canvas.getContext('2d');
        const countSpan = document.getElementById('matchCount');
        const layerListDiv = document.getElementById('layerList');
        const infoPos = document.getElementById('infoPos');
        const infoIdx = document.getElementById('infoIdx');
        const infoVal = document.getElementById('infoVal');
        const btnStart = document.getElementById('btnStart');

        const GRID_SIZE = 1001;
        const TOTAL_ITEMS = GRID_SIZE * GRID_SIZE; 
        const CX = Math.floor(GRID_SIZE / 2);
        const CY = Math.floor(GRID_SIZE / 2);

        let layers = []; 
        let manualEdits = new Map(); 
        let timeoutId;
        let lifeInterval = null;
        let isPaused = false;
        let lifeGrid = new Uint8Array(TOTAL_ITEMS);
        let nextGrid = new Uint8Array(TOTAL_ITEMS);
        let displayGrid = new Float32Array(TOTAL_ITEMS); // Ut√≥h√∫z√°s megjelen√≠t√©shez
        let ageGrid = new Uint32Array(TOTAL_ITEMS);      // √âletkor t√°rol√°s√°hoz
        let scale = 1, translateX = 0, translateY = 0;
        let panning = false, startX = 0, startY = 0;

        // --- MATEMATIKA ---
        function isPrime(num) {
            if (num <= 1) return false;
            if (num <= 3) return true;
            if (num % 2 === 0 || num % 3 === 0) return false;
            let i = 5;
            while (i * i <= num) {
                if (num % i === 0 || num % (i + 2) === 0) return false;
                i += 6;
            }
            return true;
        }
        function isSquare(num) { if(num<0)return false; const s=Math.sqrt(num); return Math.round(s)**2===num; }
        function isCube(num) { const c=Math.cbrt(num); return Math.round(c)**3===num; }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [255, 255, 255];
        }

        // --- JAV√çTOTT ULAM INDEX SZ√ÅM√çT√ÅS ---
        function getUlamIndex(gx, gy) {
            let x = gx - CX;
            let y = -(gy - CY); 
            if (x === 0 && y === 0) return 0;
            const k = Math.max(Math.abs(x), Math.abs(y)); 
            
            // Jobb oldal: x = k, y > -k
            if (x === k && y > -k) return (2*k-1)**2 + (y + k - 1);
            
            // Fels≈ë oldal: y = k, x >= -k (JAV√çTVA: > helyett >=, hogy a bal-fels≈ë sarok (-k, k) ide tartozzon)
            if (y === k && x >= -k) return ((2*k-1)**2) + (2*k - 1) + (k - x);
            
            // Bal oldal: x = -k, y < k
            if (x === -k && y < k) return ((2*k-1)**2) + (4*k - 1) + (k - y);
            
            // Als√≥ oldal: y = -k, x > -k
            if (y === -k && x > -k) return ((2*k-1)**2) + (6*k - 1) + (x + k);
            
            return 0;
        }

        function getCanvasCoordinates(e) {
            const rect = container.getBoundingClientRect();
            const clientX = e.clientX;
            const clientY = e.clientY;
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;
            const rawX = (mouseX - translateX) / scale;
            const rawY = (mouseY - translateY) / scale;
            const x = Math.floor(rawX);
            const y = Math.floor(rawY);
            return { x, y, valid: x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE };
        }

        // --- UI ---
        function getInputs() {
            return {
                start: parseInt(document.getElementById('startValue').value) || 0,
                incr: parseInt(document.getElementById('increment').value) || 1,
                mode: document.querySelector('input[name="ulamMode"]:checked').value,
                color: document.getElementById('layerColor').value
            };
        }

        function onColorChange() {
            if (lifeInterval || isPaused) renderLifeFrame();
            else drawSpiral();
        }

        function drawSpiral() {
            if (lifeInterval || isPaused) return; 
            if (timeoutId) clearTimeout(timeoutId);
            timeoutId = setTimeout(render, 15);
        }

        function addLayer() {
            const current = getInputs();
            const rgb = hexToRgb(current.color);
            layers.push({ ...current, visible: true, rgb: rgb });
            updateLayerListUI();
            drawSpiral();
        }

        function updateLayerListUI() {
            layerListDiv.innerHTML = '';
            layers.forEach((l, idx) => {
                let label = l.mode === 'step' ? `Szekv.: ${l.start} + ${l.incr}n` :
                            l.mode === 'prime' ? `Pr√≠m (${l.start})` :
                            l.mode === 'square' ? `N√©gyzet (${l.start})` : `K√∂b (${l.start})`;
                const div = document.createElement('div');
                div.className = `layer-item ${l.visible ? '' : 'hidden-layer'}`;
                div.style.borderLeftColor = l.color;
                div.innerHTML = `
                    <div class="layer-info" title="${label}"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${l.color};margin-right:8px;"></span><span>${label}</span></div>
                    <div class="layer-controls"><button class="icon-btn" onclick="toggleLayerVis(${idx})">${l.visible?'üëÅÔ∏è':'üö´'}</button><button class="icon-btn btn-delete" onclick="delLayer(${idx})">üóëÔ∏è</button></div>`;
                layerListDiv.appendChild(div);
            });
        }

        function toggleLayerVis(i) { layers[i].visible = !layers[i].visible; drawSpiral(); updateLayerListUI(); }
        function delLayer(i) { layers.splice(i, 1); drawSpiral(); updateLayerListUI(); }
        function deleteAllLayers() { if (confirm("Biztosan t√∂r√∂lsz mindent?")) { layers = []; manualEdits.clear(); resetLife(); updateLayerListUI(); } }
        function saveImage() { const link = document.createElement('a'); link.download = 'ulam_spiral.png'; link.href = canvas.toDataURL(); link.click(); }

        // --- ESEM√âNYKEZEL√âS ---
        let isDrawing = false;
        container.addEventListener('mousedown', (e) => { if (e.shiftKey && e.button === 0) { isDrawing = true; handleEdit(e); } });
        container.addEventListener('mousemove', (e) => { updateStatusPanel(e); if (isDrawing && e.shiftKey) handleEdit(e); });
        container.addEventListener('mouseleave', () => resetStatusPanel());
        
        container.addEventListener('mousedown', (e) => { if (!e.shiftKey && e.button === 0) { panning = true; startX = e.clientX - translateX; startY = e.clientY - translateY; container.style.cursor = "grabbing"; } });
        window.addEventListener('mouseup', () => { isDrawing = false; panning = false; container.style.cursor = "crosshair"; });
        window.addEventListener('mousemove', (e) => { if (panning) { e.preventDefault(); translateX = e.clientX - startX; translateY = e.clientY - startY; applyTransform(); } });

        function resetStatusPanel() { infoPos.textContent = "-"; infoIdx.textContent = "-"; infoVal.textContent = "-"; }
        function updateStatusPanel(e) {
            const pos = getCanvasCoordinates(e);
            if (pos.valid) {
                const relX = pos.x - CX; const relY = -(pos.y - CY); 
                const ulamIdx = getUlamIndex(pos.x, pos.y);
                const inputs = getInputs(); 
                const val = inputs.start + (ulamIdx * inputs.incr);
                infoPos.textContent = `X:${relX} Y:${relY}`; infoIdx.textContent = ulamIdx; infoVal.textContent = val.toLocaleString();
            } else { resetStatusPanel(); }
        }

        function handleEdit(e) {
            const pos = getCanvasCoordinates(e);
            if (!pos.valid) return;
            const idx = pos.y * GRID_SIZE + pos.x;
            if (lifeInterval || isPaused) { lifeGrid[idx] = lifeGrid[idx] ? 0 : 1; if (isPaused) renderLifeFrame(); }
            else { if (manualEdits.has(idx)) manualEdits.delete(idx); else manualEdits.set(idx, 1); render(); }
        }

        function render() {
            const current = getInputs(); const currentRgb = hexToRgb(current.color);
            const imgData = ctx.createImageData(GRID_SIZE, GRID_SIZE); const data = imgData.data;
            
            // Ha 'empty' m√≥d van kiv√°lasztva, nem rajzoljuk ki a r√©tegeket, csak a k√©zi m√≥dos√≠t√°sokat
            const showLayers = current.mode !== 'empty';
            const queue = []; 
            
            if (showLayers) {
                layers.forEach(l => { if(l.visible) queue.push(l); }); 
                queue.push({ ...current, isPreview: true, rgb: currentRgb });
            }

            let x = 0, y = 0, dx = 1, dy = 0, segmentLength = 1, segmentPassed = 0, turnCount = 0;
            let count = 0;
            for (let i = 0; i < TOTAL_ITEMS; i++) {
                const cx = CX + x; const cy = CY - y; const pixelIndex = (cy * GRID_SIZE + cx) * 4; const manualIdx = cy * GRID_SIZE + cx;
                let r=0, g=0, b=0, a=0;
                
                if (showLayers) {
                    for (let l = 0; l < queue.length; l++) {
                        const layer = queue[l]; let isMatch = false;
                        if (layer.mode === 'step') { if (i >= layer.start && (i - layer.start) % layer.incr === 0) isMatch = true; }
                        else { const val = layer.start + (i * layer.incr); if (layer.mode === 'prime') isMatch = isPrime(val); else if (layer.mode === 'square') isMatch = isSquare(val); else if (layer.mode === 'cube') isMatch = isCube(val); }
                        if (isMatch) { r = layer.rgb[0]; g = layer.rgb[1]; b = layer.rgb[2]; a = 255; }
                    }
                }

                if (manualEdits.has(manualIdx)) { if (a === 0) { r=255; g=255; b=255; a=255; } else { r=0; g=0; b=0; a=255; } }
                if (a > 0) { data[pixelIndex] = r; data[pixelIndex+1] = g; data[pixelIndex+2] = b; data[pixelIndex+3] = a; count++; }
                if (i < TOTAL_ITEMS - 1) { x += dx; y += dy; segmentPassed++; if (segmentPassed === segmentLength) { segmentPassed = 0; const tempDx = dx; dx = -dy; dy = tempDx; turnCount++; if (turnCount % 2 === 0) segmentLength++; } }
            }
            ctx.putImageData(imgData, 0, 0); ctx.fillStyle = 'white'; ctx.fillRect(CX, CY, 1, 1);
            countSpan.textContent = count.toLocaleString();
        }

        function toggleLife() { if (lifeInterval) pauseLife(); else if (isPaused) resumeLife(); else initLife(); }
        function initLife() {
            const current = getInputs(); const currentRgb = hexToRgb(current.color);
            const showLayers = current.mode !== 'empty';
            
            const queue = []; 
            if (showLayers) {
                layers.forEach(l => { if(l.visible) queue.push(l); }); 
                queue.push({ ...current, rgb: currentRgb });
            }

            lifeGrid.fill(0);
            displayGrid.fill(0); // Reset Trail
            ageGrid.fill(0);     // Reset Age
            let x = 0, y = 0, dx = 1, dy = 0, segmentLength = 1, segmentPassed = 0, turnCount = 0;
            for (let i = 0; i < TOTAL_ITEMS; i++) {
                let isAlive = 0;
                
                if (showLayers) {
                    for (let l = 0; l < queue.length; l++) {
                        const layer = queue[l];
                        if (layer.mode === 'step') { if (i >= layer.start && (i - layer.start) % layer.incr === 0) isAlive = 1; }
                        else { const val = layer.start + (i * layer.incr); if (layer.mode === 'prime' && isPrime(val)) isAlive = 1; else if (layer.mode === 'square' && isSquare(val)) isAlive = 1; else if (layer.mode === 'cube' && isCube(val)) isAlive = 1; }
                        if (isAlive) break;
                    }
                }

                const idx = (CY - y) * GRID_SIZE + (CX + x); if (manualEdits.has(idx)) isAlive = isAlive ? 0 : 1; lifeGrid[idx] = isAlive;
                // Init extra grids
                if (isAlive) {
                    displayGrid[idx] = 255;
                    ageGrid[idx] = 1;
                }
                if (i < TOTAL_ITEMS - 1) { x += dx; y += dy; segmentPassed++; if (segmentPassed === segmentLength) { segmentPassed = 0; const tempDx = dx; dx = -dy; dy = tempDx; turnCount++; if (turnCount % 2 === 0) segmentLength++; } }
            }
            resumeLife();
        }
        function pauseLife() { clearInterval(lifeInterval); lifeInterval = null; isPaused = true; btnStart.textContent = "Folytat√°s"; btnStart.style.background = "#28a745"; }
        function resumeLife() { isPaused = false; btnStart.textContent = "Sz√ºnet"; btnStart.style.background = "#ffc107"; btnStart.style.color = "#000"; lifeInterval = setInterval(stepLife, 100); }
        function resetLife() { pauseLife(); isPaused = false; btnStart.textContent = "Start"; btnStart.style.background = "#28a745"; btnStart.style.color = "#fff"; render(); }
        function clearScreen() {
            pauseLife();
            isPaused = false;
            btnStart.textContent = "Start"; 
            btnStart.style.background = "#28a745"; 
            btnStart.style.color = "#fff";
            
            lifeGrid.fill(0);
            displayGrid.fill(0);
            ageGrid.fill(0);
            manualEdits.clear(); // A k√©zi szerkeszt√©seket is t√∂r√∂lj√ºk
            
            // Ha Ulam m√≥dban vagyunk (nincs lifeGrid renderelve?), akkor a render() h√≠v√°s kirajzolja az Ulam spir√°lt.
            // De a felhaszn√°l√≥ "teljesen √ºres" k√©pet akar.
            // Ha Ulam r√©tegek vannak, azok kirajzol√≥dnak.
            // A "T√∂rl√©s" gomb a Game of Life szekci√≥ban van.
            // Val√≥sz√≠n≈±leg az √âletj√°t√©k √°llapot√°t akarja t√∂r√∂lni (√ºres r√°cs).
            // De ha r√©tegek vannak, azok "√∫jragener√°lj√°k" az √©letet a Start-n√°l?
            // A "resetLife" visszat√©r az Ulam n√©zethez.
            // A "clearScreen" legyen az, hogy:
            // 1. Meg√°ll√≠t.
            // 2. √úr√≠t mindent (lifeGrid = 0).
            // 3. Renderel egy √úRES life frame-et (fekete k√©perny≈ë).
            
            // De ha render()-t h√≠vok, az kirajzolja a spir√°lt.
            // Ha renderLifeFrame()-t h√≠vok √ºres r√°ccsal, az fekete.
            renderLifeFrame();
            
            // Fontos: Ha a felhaszn√°l√≥ ezut√°n Start-ot nyom, az `initLife` lefut, √©s √öJRAT√ñLTI a spir√°lt!
            // Teh√°t ha "√ºresr≈ël" akar indulni, akkor a r√©tegeket ki kell kapcsolni?
            // Vagy `initLife` ne t√∂lts√∂n be semmit?
            // A `toggleLife` h√≠vja az `initLife`-ot.
            // Megold√°s: A `clearScreen` ne csak rendereljen, hanem jelezze, hogy "tiszta lappal" indulunk.
            // De az `initLife` logika: `layers.forEach...`.
            // Ha a felhaszn√°l√≥ manu√°lisan rajzolni akar egy √ºres r√°csra, akkor az `initLife` bekavar.
            
            // M√≥dos√≠tsuk az `initLife`-ot, hogy csak akkor t√∂lts√∂n be, ha NEM volt clear?
            // Vagy egyszer≈±en: A `clearScreen` t√∂rli a `layers`-t is? Nem, az drasztikus.
            // A `deleteAllLayers` m√°r l√©tezik.
            
            // A felhaszn√°l√≥ val√≥sz√≠n≈±leg csak a "szemetet" akarja elt√ºntetni a k√©perny≈ër≈ël.
            // Ha ut√°na rajzolni akar (shift+click), √©s Start-ot nyom...
            // A `handleEdit` Life m√≥dban a `lifeGrid`-et m√≥dos√≠tja.
            // Ha Start-ot nyom, az `initLife` fel√ºl√≠rja?
            // IGEN! Az `initLife` mindig √∫jra√©p√≠ti a r√°csot a r√©tegekb≈ël.
            // Ez a program logik√°ja: A spir√°l a "forr√°s".
            
            // Ha a felhaszn√°l√≥ "√ºres" r√°csot akar, akkor ki kell kapcsolnia a r√©tegeket, vagy t√∂r√∂lni ≈ëket.
            // De tegy√ºk fel, hogy csak a "Game of Life" szimul√°ci√≥ eredm√©ny√©t akarja t√∂r√∂lni, √©s l√°tni a s√∂t√©ts√©get.
            // Rendben, a fenti k√≥d ezt teszi.
        }

        const LIFE_RULES = {
            life:           { b: 1<<3, s: (1<<2)|(1<<3) },
            highlife:       { b: (1<<3)|(1<<6), s: (1<<2)|(1<<3) },
            daynight:       { b: (1<<3)|(1<<6)|(1<<7)|(1<<8), s: (1<<3)|(1<<4)|(1<<6)|(1<<7)|(1<<8) },
            seeds:          { b: 1<<2, s: 0 },
            diamoeba:       { b: (1<<3)|(1<<5)|(1<<6)|(1<<7)|(1<<8), s: (1<<5)|(1<<6)|(1<<7)|(1<<8) },
            morley:         { b: (1<<3)|(1<<6)|(1<<8), s: (1<<2)|(1<<4)|(1<<5) },
            // √öjak:
            replicator:     { b: (1<<1)|(1<<3)|(1<<5)|(1<<7), s: (1<<1)|(1<<3)|(1<<5)|(1<<7) },
            walledcities:   { b: (1<<4)|(1<<5)|(1<<6)|(1<<7)|(1<<8), s: (1<<2)|(1<<3)|(1<<4)|(1<<5) },
            stains:         { b: (1<<3)|(1<<6)|(1<<7)|(1<<8), s: (1<<2)|(1<<3)|(1<<5)|(1<<6)|(1<<7)|(1<<8) },
            maze:           { b: 1<<3, s: (1<<1)|(1<<2)|(1<<3)|(1<<4)|(1<<5) },
            anneal:         { b: (1<<4)|(1<<6)|(1<<7)|(1<<8), s: (1<<3)|(1<<5)|(1<<6)|(1<<7)|(1<<8) }
        };

        // Init checkboxok gener√°l√°sa (0-t√≥l 8-ig)
        function initRuleEditor() {
            const bSel = document.getElementById('bornSelector');
            const sSel = document.getElementById('surviveSelector');
            
            for(let i=0; i<=8; i++) {
                // Born
                bSel.innerHTML += `
                    <input type="checkbox" id="b${i}" class="bit-chk" onchange="updateRuleString()">
                    <label for="b${i}" class="bit-label">${i}</label>
                `;
                // Survive
                sSel.innerHTML += `
                    <input type="checkbox" id="s${i}" class="bit-chk" onchange="updateRuleString()">
                    <label for="s${i}" class="bit-label">${i}</label>
                `;
            }
        }
        // H√≠vjuk meg az oldal bet√∂lt√©sekor!
        initRuleEditor();

        function toggleRuleEditor() {
            const val = document.getElementById('lifeRule').value;
            const editor = document.getElementById('customRuleEditor');
            
            if (val === 'custom') {
                editor.style.display = 'block';
                // Ha customra v√°ltunk, √°ll√≠tsuk be a checkboxokat a jelenlegi "Life" szab√°lyra alapnak (opcion√°lis)
                // Vagy hagyjuk √ºresen. Most hagyjuk a felhaszn√°l√≥ra.
            } else {
                editor.style.display = 'none';
                // Ha visszav√°ltunk fix szab√°lyra, √°ll√≠tsuk le a custom m√≥dot (a stepLife kezeli)
            }
        }

        function updateRuleString() {
            let bStr = "", sStr = "";
            for(let i=0; i<=8; i++) {
                if(document.getElementById(`b${i}`).checked) bStr += i;
                if(document.getElementById(`s${i}`).checked) sStr += i;
            }
            document.getElementById('ruleNameDisplay').textContent = `B${bStr}/S${sStr}`;
        }

        function onColorModeChange() {
            const mode = document.getElementById('colorMode').value;
            // Ha Trail m√≥dba v√°ltunk, √©s a r√°cs tele van "szem√©ttel" vagy r√©g√≥ta fut,
            // √©rdemes lehet √∫jrakalkul√°lni a jelenlegi lifeGrid alapj√°n.
            // De mivel a stepLife folyamatosan friss√≠ti a h√°tt√©rben is, elvileg j√≥.
            // A probl√©ma az lehet, hogy a displayGrid "t√∂rt√©nelme" nem relev√°ns, ha most v√°ltunk.
            // Vagy √©pp ellenkez≈ëleg: azt akarjuk l√°tni.
            
            // A felhaszn√°l√≥ panasza: "el≈ëz≈ë k√©ptartalom megjelenik".
            // Val√≥sz√≠n≈±leg arra gondol, hogy a Trail m√≥d bekapcsol√°sakor a "m√∫lt" hirtelen megjelenik,
            // ami zavar√≥ lehet, ha eddig nem l√°ttuk.
            // Vagy Age m√≥dn√°l hirtelen sz√≠nes lesz minden.
            
            // A legbiztosabb, ha a jelenlegi pillanatra "szinkroniz√°ljuk" a n√©zetet.
            // Trail m√≥dn√°l: A jelenleg √©l≈ë sejtek legyenek 255, a t√∂bbi 0 (t√∂r√∂lj√ºk a t√∂rt√©nelmet).
            // Age m√≥dn√°l: A jelenleg √©l≈ë sejtek kora maradjon meg (hiszen az val√≥s adat),
            // de ha esetleg inkonzisztens lenne, akkor... a stepLife karbantartja.
            
            // A felhaszn√°l√≥ k√©r√©se: "mindig az aktu√°lisan kiv√°lasztott param√©terek alapj√°n sz√°molja ki".
            // Ha Trail-re v√°ltunk, resetelj√ºk a trail-t (csak az √©l≈ëk l√°tszanak, nincs cs√≥va).
            if (mode === 'trail') {
                for(let i=0; i<TOTAL_ITEMS; i++) {
                    displayGrid[i] = lifeGrid[i] ? 255 : 0;
                }
            }
            renderLifeFrame();
        }

        // Seg√©df√ºggv√©ny a Custom szab√°ly kinyer√©s√©re
        function getCustomRuleMasks() {
            let b = 0, s = 0;
            for(let i=0; i<=8; i++) {
                if(document.getElementById(`b${i}`).checked) b |= (1 << i);
                if(document.getElementById(`s${i}`).checked) s |= (1 << i);
            }
            return { b, s };
        }

        function stepLife() {
            const ruleKey = document.getElementById('lifeRule').value;
            let rule;

            if (ruleKey === 'custom') {
                rule = getCustomRuleMasks(); // Checkboxokb√≥l olvassuk ki
            } else {
                rule = LIFE_RULES[ruleKey] || LIFE_RULES.life;
            }
            
            nextGrid.fill(0);
            for (let y = 1; y < GRID_SIZE - 1; y++) {
                let rowOffset = y * GRID_SIZE;
                for (let x = 1; x < GRID_SIZE - 1; x++) {
                    const idx = rowOffset + x;
                    let neighbors = lifeGrid[idx - GRID_SIZE - 1] + lifeGrid[idx - GRID_SIZE] + lifeGrid[idx - GRID_SIZE + 1] + lifeGrid[idx - 1] + lifeGrid[idx + 1] + lifeGrid[idx + GRID_SIZE - 1] + lifeGrid[idx + GRID_SIZE] + lifeGrid[idx + GRID_SIZE + 1];

                    const cell = lifeGrid[idx];
                    // Haszn√°ljuk a maszkokat
                    if (cell === 1) { 
                        if ((rule.s >> neighbors) & 1) nextGrid[idx] = 1; 
                    } else { 
                        if ((rule.b >> neighbors) & 1) nextGrid[idx] = 1; 
                    }
                }
            }
            // ... swap √©s renderel√©s ...
            let temp = lifeGrid; lifeGrid = nextGrid; nextGrid = temp;
            
            // Friss√≠ts√ºk az extra r√°csokat (Trail √©s Age)
            for (let i = 0; i < TOTAL_ITEMS; i++) {
                if (lifeGrid[i] === 1) {
                    displayGrid[i] = 255;
                    ageGrid[i]++; // N√∂velj√ºk a kort
                } else {
                    displayGrid[i] = Math.max(0, displayGrid[i] * 0.9); // Cs√∂kkentj√ºk a f√©nyer≈ët
                    ageGrid[i] = 0; // Resetelj√ºk a kort
                }
            }

            renderLifeFrame();
        }

        function renderLifeFrame() {
            const imgData = ctx.createImageData(GRID_SIZE, GRID_SIZE); const data = imgData.data;
            const colorInput = document.getElementById('layerColor').value; const baseRgb = hexToRgb(colorInput);
            const mode = document.getElementById('colorMode').value;
            let count = 0;

            for (let i = 0; i < TOTAL_ITEMS; i++) {
                const idx = i * 4;
                let r = 0, g = 0, b = 0, a = 0;

                if (mode === 'static') {
                    if (lifeGrid[i]) {
                        r = baseRgb[0]; g = baseRgb[1]; b = baseRgb[2]; a = 255;
                        count++;
                    }
                } 
                else if (mode === 'trail') {
                    const val = displayGrid[i];
                    if (val > 1) { // Csak ha l√°that√≥
                        // Sz√≠n√°tmenet: BaseColor -> ... -> Black
                        // Egyszer≈±s√≠tett: BaseColor s√∂t√©t√≠t√©se
                        // A k√©r√©s: s√°rga -> v√∂r√∂s -> s√∂t√©tlila -> fekete
                        // Ehhez HSL jobb lenne, vagy egy tr√ºkk√∂s RGB kever√©s.
                        // Haszn√°ljunk egy egyszer≈± intenzit√°s alap√∫ s√∂t√©t√≠t√©st a v√°lasztott sz√≠nb≈ël.
                        // Vagy ha s√°rga (255,255,0), akkor cs√∂kkents√ºk a Z√∂ldet gyorsabban, hogy V√∂r√∂s legyen?
                        
                        const intensity = val / 255;
                        
                        // Egyedi "t≈±z" effektus gener√°l√°sa a b√°zis sz√≠nb≈ël
                        // Ha a b√°zis sz√≠n vil√°gos (pl S√°rga), akkor v√∂r√∂sbe hajlik.
                        // Ha K√©k, akkor s√∂t√©tk√©kbe.
                        
                        // Pr√≥b√°ljuk megval√≥s√≠tani a k√©rt √°tmenetet a s√°rga p√©lda alapj√°n √°ltal√°nosan:
                        // "Heat map" szer≈± sz√≠nez√©s.
                        
                        // De tartsuk tiszteletben a felhaszn√°l√≥ sz√≠nv√°laszt√°s√°t?
                        // "A 255-√∂s √©rt√©k a kiv√°lasztott '√âl≈ë' sz√≠n."
                        
                        r = baseRgb[0] * intensity;
                        g = baseRgb[1] * (intensity * intensity); // Gyorsabb s√∂t√©ted√©s = sz√≠n eltol√≥d√°s
                        b = baseRgb[2] * (intensity * intensity * intensity);
                        a = 255;
                        
                        if (lifeGrid[i]) count++;
                    }
                }
                else if (mode === 'age') {
                    if (lifeGrid[i]) {
                        const age = ageGrid[i];
                        let h, s, l;
                        
                        // HSL konverzi√≥ logik√°ja a le√≠r√°s alapj√°n
                        if (age === 1) {
                            // √öjsz√ºl√∂tt: Feh√©r (vagy majdnem feh√©r)
                            h = 0; s = 0; l = 100; 
                        } else if (age < 10) {
                            // Fiatal: Z√∂ld (120)
                            h = 120; s = 100; l = 50;
                        } else if (age < 100) {
                            // √ñreg: K√©k (240)
                            h = 240; s = 100; l = 50;
                        } else {
                            // Matuzs√°lem: Piros (0)
                            h = 0; s = 100; l = 50;
                        }

                        // HSL to RGB konverzi√≥ (egyszer≈±s√≠tett vagy seg√©df√ºggv√©ny)
                        // Itt inline megoldjuk
                        const c = (1 - Math.abs(2 * l / 100 - 1)) * (s / 100);
                        const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
                        const m = l / 100 - c / 2;
                        let rP, gP, bP;

                        if (h < 60) { rP=c; gP=x; bP=0; }
                        else if (h < 120) { rP=x; gP=c; bP=0; }
                        else if (h < 180) { rP=0; gP=c; bP=x; }
                        else if (h < 240) { rP=0; gP=x; bP=c; }
                        else if (h < 300) { rP=x; gP=0; bP=c; }
                        else { rP=c; gP=0; bP=x; }

                        r = (rP + m) * 255;
                        g = (gP + m) * 255;
                        b = (bP + m) * 255;
                        a = 255;
                        count++;
                    }
                }

                if (a > 0) {
                    data[idx] = r; data[idx+1] = g; data[idx+2] = b; data[idx+3] = a;
                }
            }
            ctx.putImageData(imgData, 0, 0); countSpan.textContent = count.toLocaleString();
        }

        function applyTransform() { canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`; }
        function fitToScreen() { const rect = container.getBoundingClientRect(); const s = Math.min((rect.width-20)/GRID_SIZE, (rect.height-20)/GRID_SIZE, 1); scale = Math.max(s, 0.1); translateX = (rect.width - GRID_SIZE*scale)/2; translateY = (rect.height - GRID_SIZE*scale)/2; applyTransform(); }
        setTimeout(fitToScreen, 100); window.addEventListener('resize', fitToScreen);
        container.addEventListener('wheel', e => { e.preventDefault(); const rect = container.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; const factor = Math.exp((e.deltaY<0?1:-1)*0.1); const nextScale = scale * factor; translateX = mx - (mx - translateX) * factor; translateY = my - (my - translateY) * factor; scale = nextScale; applyTransform(); });

        // --- √öJ GUI FUNKCI√ìK ---
        function toggleSidebar() {
            const sb = document.getElementById('sidebar');
            sb.classList.toggle('hidden');
        }

        function toggleSection(header) {
            const content = header.nextElementSibling;
            content.classList.toggle('collapsed');
        }

        function zoomCanvas(factor) {
            const rect = container.getBoundingClientRect();
            // Zoom center (screen center)
            const cx = rect.width / 2;
            const cy = rect.height / 2;
            
            const nextScale = scale * factor;
            translateX = cx - (cx - translateX) * factor;
            translateY = cy - (cy - translateY) * factor;
            scale = nextScale;
            applyTransform();
        }

        function exportConfig() {
            const config = {
                layers: layers,
                settings: getInputs(),
                lifeRule: document.getElementById('lifeRule').value,
                customRule: getCustomRuleMasks(), // Ez egy objektum {b,s}
                customRuleChecks: {
                    b: Array.from({length:9}, (_,i) => document.getElementById(`b${i}`).checked),
                    s: Array.from({length:9}, (_,i) => document.getElementById(`s${i}`).checked)
                },
                colorMode: document.getElementById('colorMode').value
            };
            const blob = new Blob([JSON.stringify(config, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ulam_projekt.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importConfig(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const config = JSON.parse(e.target.result);
                    
                    // R√©tegek bet√∂lt√©se
                    if (config.layers) layers = config.layers;
                    
                    // Be√°ll√≠t√°sok bet√∂lt√©se
                    if (config.settings) {
                        document.getElementById('startValue').value = config.settings.start;
                        document.getElementById('increment').value = config.settings.incr;
                        const modeRadio = document.querySelector(`input[name="ulamMode"][value="${config.settings.mode}"]`);
                        if (modeRadio) modeRadio.checked = true;
                        // Sz√≠n nem kritikus
                    }

                    // √âletj√°t√©k szab√°lyok
                    if (config.lifeRule) {
                        document.getElementById('lifeRule').value = config.lifeRule;
                        toggleRuleEditor();
                    }
                    if (config.customRuleChecks && config.lifeRule === 'custom') {
                        config.customRuleChecks.b.forEach((chk, i) => document.getElementById(`b${i}`).checked = chk);
                        config.customRuleChecks.s.forEach((chk, i) => document.getElementById(`s${i}`).checked = chk);
                        updateRuleString();
                    }

                    // Sz√≠nez√©si m√≥d
                    if (config.colorMode) {
                        document.getElementById('colorMode').value = config.colorMode;
                    }

                    // Friss√≠t√©s
                    updateLayerListUI();
                    drawSpiral();
                    if (config.colorMode === 'trail') onColorModeChange(); // Init trail grid
                    alert("Sikeres bet√∂lt√©s!");
                } catch (err) {
                    alert("Hiba a f√°jl beolvas√°sakor: " + err);
                }
            };
            reader.readAsText(file);
            input.value = ''; // Reset input
        }

        drawSpiral();
    </script>
</body>
</html>
