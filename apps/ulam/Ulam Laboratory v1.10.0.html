<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ulam Laborat√≥rium v1.10.0</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #eee;
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            justify-content: center;
            padding: 10px;
            margin: 0;
            min-height: 100vh;
            box-sizing: border-box;
            height: 100vh;
            overflow: hidden;
        }
        
        .controls {
            position: fixed; /* Changed to fixed for sidebar toggle */
            left: 0; top: 0; bottom: 0;
            z-index: 100;
            background: #2d2d2d;
            padding: 0; /* Reset padding for sections */
            display: flex;
            flex-direction: column;
            width: 300px;
            box-shadow: 4px 0 15px rgba(0,0,0,0.5);
            border-right: 1px solid #444;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }
        .controls.hidden { transform: translateX(-100%); }
        
        .sidebar-toggle {
            position: fixed;
            top: 10px; left: 10px;
            z-index: 200;
            background: #2d2d2d;
            color: #eee;
            border: 1px solid #444;
            border-radius: 4px;
            width: 32px; height: 32px;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: left 0.3s ease;
        }
        .controls:not(.hidden) + .sidebar-toggle { left: 310px; } /* Move button when sidebar is open */

        /* Accordion Styles */
        .control-section { border-bottom: 1px solid #444; }
        .section-header {
            padding: 12px 15px;
            background: #333;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.85rem;
            color: #eee;
            display: flex; justify-content: space-between; align-items: center;
            user-select: none;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .section-header:hover { background: #3a3a3a; }
        .section-content {
            padding: 15px;
            display: flex; flex-direction: column; gap: 10px;
            background: #262626;
        }
        .section-content.collapsed { display: none; }
        .arrow { transition: transform 0.2s; font-size: 0.7rem; }
        .section-content.collapsed + .arrow { transform: rotate(-90deg); } /* Logic handled in JS mostly */

        .control-group { display: flex; flex-direction: column; margin-bottom: 5px; }
        label { font-size: 0.75rem; margin-bottom: 4px; color: #bbb; text-transform: uppercase; letter-spacing: 0.5px; font-weight: bold; }
        input[type="number"], select { background: #3a3a3a; border: 1px solid #555; color: white; padding: 6px; border-radius: 4px; font-size: 0.9rem; }
        input[type="number"]:focus, select:focus { outline: none; border-color: #007bff; }

        .info-panel {
            background: #222;
            border: 1px solid #007bff;
            padding: 10px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9rem;
            color: #00ffaa;
            height: 110px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            gap: 5px;
        }
        .info-row { display: flex; justify-content: space-between; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .info-label { color: #888; }
        .info-val { font-weight: bold; color: white; }
        .info-big { font-size: 1.2rem; color: #ffcc00; text-align: center; margin-top: auto; padding-top: 5px; }

        .mode-selector { display: flex; flex-direction: column; gap: 6px; background: #222; padding: 8px; border-radius: 6px; border: 1px solid #444; }
        .mode-selector label { margin: 0; cursor: pointer; color: #ddd; font-weight: normal; display: flex; align-items: center; gap: 8px; text-transform: none; font-size: 0.85rem; padding: 2px; }
        .mode-selector label:hover { background: #333; }

        .add-layer-group { display: flex; gap: 5px; align-items: center; }
        input[type="color"] { background: none; border: none; width: 40px; height: 36px; cursor: pointer; padding: 0; }
        .main-action-btn { 
            background: linear-gradient(to bottom, #007bff, #0069d9); 
            color: white; border: 1px solid #0056b3; 
            padding: 8px; border-radius: 4px; cursor: pointer; 
            font-weight: bold; flex-grow: 1; font-size: 0.8rem; text-transform: uppercase; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .main-action-btn:hover { background: linear-gradient(to bottom, #0069d9, #0056b3); }
        
        .layer-list { display: flex; flex-direction: column; gap: 5px; font-size: 0.8rem; margin-top: 0; min-height: 50px; max-height: 250px; overflow-y: auto; padding-right: 5px; }
        .layer-list::-webkit-scrollbar { width: 6px; }
        .layer-list::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }
        .layer-item { background: #333; padding: 6px 8px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; border-left: 4px solid transparent; flex-shrink: 0; }
        .layer-item.hidden-layer { opacity: 0.5; background: #252525; }
        .layer-info { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; display: flex; align-items: center; flex: 1; min-width: 0; }
        .layer-controls { display: flex; gap: 4px; }
        .icon-btn { background: #444; border: 1px solid #555; color: #eee; width: 24px; height: 24px; border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; }
        .icon-btn:hover { background: #555; }
        .btn-delete:hover { background: #602020; border-color: #ff4444; }

        .canvas-container { 
            background-color: #000; 
            box-shadow: inset 0 0 50px rgba(0,0,0,0.8); 
            border: 2px solid #555; /* L√°that√≥ keret */
            overflow: hidden; 
            flex-grow: 1; 
            display: block; 
            position: relative; 
            height: 100%; 
            margin-left: 300px; /* Offset for sidebar */
            transition: margin-left 0.3s ease;
        }
        .controls.hidden ~ .canvas-container { margin-left: 0; }
        canvas { 
            display: block; 
            image-rendering: pixelated; 
            transform-origin: 0 0; 
            outline: 1px solid #666; /* Outline is drawn outside the element */
        }

        /* Canvas Overlay Controls */
        .canvas-controls {
            position: absolute;
            bottom: 20px; right: 20px;
            display: flex; gap: 5px;
            z-index: 50;
        }
        .canvas-btn {
            width: 36px; height: 36px;
            background: rgba(40, 40, 40, 0.8);
            border: 1px solid #555;
            border-radius: 50%;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .canvas-btn:hover { background: rgba(60, 60, 60, 0.9); transform: scale(1.1); }

        .gol-controls { display: flex; gap: 5px; margin-top: 8px; }
        .gol-btn { flex: 1; padding: 8px; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 0.8rem; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .gol-btn:active { transform: translateY(1px); box-shadow: none; }
        
        .secondary-btn { background: #555; color: white; border: none; padding: 8px; width: 100%; margin-top: 5px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: background 0.2s; }
        .secondary-btn:hover { background: #666; }
        .delete-all-btn { background: #a72828; }
        .delete-all-btn:hover { background: #c53030; }

        .helper-text { font-size: 0.7rem; color: #888; margin-top: 5px; font-style: italic; text-align: center; }

        .bit-selector {
            display: flex;
            justify-content: space-between;
            background: #222;
            padding: 2px;
            border-radius: 4px;
        }
        .bit-chk {
            display: none; /* Rejtett checkbox */
        }
        .bit-label {
            flex: 1;
            text-align: center;
            cursor: pointer;
            padding: 4px 0;
            font-size: 0.8rem;
            color: #666;
            user-select: none;
            transition: all 0.2s;
            border-radius: 2px;
        }
        .bit-label:hover { background: #444; }
        /* Ha be van pip√°lva a rejtett checkbox, a label st√≠lusa v√°ltozik */
        .bit-chk:checked + .bit-label {
            background: #007bff;
            color: white;
            font-weight: bold;
        }
        /* K√ºl√∂n sz√≠n a Survive-nak, hogy ne keverj√ºk √∂ssze */
        #surviveSelector .bit-chk:checked + .bit-label {
            background: #28a745;
        }

        /* Drawing Tools */
        .drawing-tools { display: flex; gap: 5px; justify-content: space-between; }
        .tool-btn {
            flex: 1;
            background: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .tool-btn:hover { background: #444; }
        .tool-btn.active {
            background: #007bff;
            border-color: #0056b3;
            color: white;
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.5);
        }

    </style>
</head>
<body>

    <div class="controls" id="sidebar">
        
        <div style="padding: 15px; border-bottom: 1px solid #444; background: #252525;">
            <h2 style="margin: 0; font-size: 1.2rem; color: #fff;">Ulam Laborat√≥rium <small style="font-size: 0.8rem; color: #888;">v1.10.0</small></h2>
        </div>

        <!-- SECTION 1: KURZOR & INF√ì -->
        <div class="control-section">
            <div class="section-header" onclick="toggleSection(this)">Kurzor & Inf√≥ <span class="arrow">‚ñº</span></div>
            <div class="section-content">
                <div class="info-panel" id="statusPanel">
                    <div class="info-row"><span class="info-label">Poz√≠ci√≥:</span> <span class="info-val" id="infoPos">-</span></div>
                    <div class="info-row"><span class="info-label">Index:</span> <span class="info-val" id="infoIdx">-</span></div>
                    <div style="font-size:0.75rem; color:#888; margin-top:5px;">Sz√°m√©rt√©k (Szekvencia):</div>
                    <div class="info-big" id="infoVal">-</div>
                </div>
            </div>
        </div>

        <!-- SECTION 2: ULAM PARAM√âTEREK -->
        <div class="control-section">
            <div class="section-header" onclick="toggleSection(this)">Ulam Param√©terek <span class="arrow">‚ñº</span></div>
            <div class="section-content">
                <div class="control-group">
                    <label for="startValue">Kezd≈ë√©rt√©k</label>
                    <input type="number" id="startValue" value="0" min="0" oninput="drawSpiral()">
                </div>
                <div class="control-group">
                    <label for="increment">N√∂vekm√©ny</label>
                    <input type="number" id="increment" value="1" min="1" oninput="drawSpiral()">
                </div>

                <label style="margin-top:10px;">Elrendez√©s</label>
                <div class="mode-selector">
                    <label><input type="radio" name="layoutMode" value="spiral" checked onchange="drawSpiral()"> Ulam Spir√°l</label>
                    <label><input type="radio" name="layoutMode" value="linear" onchange="drawSpiral()"> Line√°ris</label>
                    <label><input type="radio" name="layoutMode" value="sacks" onchange="drawSpiral()"> Sacks Spir√°l</label>
                    <label><input type="radio" name="layoutMode" value="vogel" onchange="drawSpiral()"> Vogel Spir√°l</label>
                </div>
                
                <div class="mode-selector">
                    <label><input type="radio" name="ulamMode" value="prime" checked onchange="drawSpiral()"> Pr√≠m</label>
                    <label><input type="radio" name="ulamMode" value="square" onchange="drawSpiral()"> N√©gyzet</label>
                    <label><input type="radio" name="ulamMode" value="cube" onchange="drawSpiral()"> K√∂b</label>
                    <label><input type="radio" name="ulamMode" value="step" onchange="drawSpiral()"> Szekvencia</label>
                    <label><input type="radio" name="ulamMode" value="empty" onchange="drawSpiral()"> √úres (Csak k√∂z√©ppont)</label>
                </div>

                <div class="control-group" style="margin-top:10px;">
                    <label for="gridSize">R√°cs M√©ret (Grid Size)</label>
                    <div style="display:flex; align-items:center; gap:5px;">
                        <button class="icon-btn" onclick="changeGridSize(-10)">-</button>
                        <input type="range" id="gridSizeSlider" min="10" max="1001" value="1001" step="1" oninput="updateGridSize(this.value)" style="flex:1;">
                        <button class="icon-btn" onclick="changeGridSize(10)">+</button>
                    </div>
                    <input type="number" id="gridSizeInput" value="1001" min="10" max="1001" onchange="updateGridSize(this.value)" style="text-align:center; margin-top:2px;">
                </div>
            </div>
        </div>

        <!-- SECTION 3: R√âTEGEK -->
        <div class="control-section">
            <div class="section-header" onclick="toggleSection(this)">R√©tegek <span class="arrow">‚ñº</span></div>
            <div class="section-content">
                <label>√öj r√©teg hozz√°ad√°sa / Sz√≠n</label>
                <div class="add-layer-group">
                    <input type="color" id="layerColor" value="#ffff00" title="V√°lassz sz√≠nt" oninput="onColorChange()">
                    <button class="main-action-btn" onclick="addLayer()">+ Hozz√°ad√°s</button>
                </div>
                <div class="layer-list" id="layerList"></div>
            </div>
        </div>

        <!-- SECTION 4: √âLETJ√ÅT√âK -->
        <div class="control-section">
            <div class="section-header" onclick="toggleSection(this)">√âletj√°t√©k <span class="arrow">‚ñº</span></div>
            <div class="section-content">
                <label>Szab√°lyok</label>
                <select id="lifeRule" onchange="toggleRuleEditor()">
                    <option value="life" selected>Game of Life (B3/S23)</option>
                    <option value="highlife">HighLife (B36/S23)</option>
                    <option value="daynight">Day & Night (B3678/S34678)</option>
                    <option value="seeds">Seeds (B2/S)</option>
                    <option value="diamoeba">Diamoeba (B35678/S5678)</option>
                    <option value="morley">Morley (B368/S245)</option>
                    <option value="replicator">Replicator (B1357/S1357)</option>
                    <option value="walledcities">Walled Cities (B45678/S2345)</option>
                    <option value="stains">Stains (B3678/S235678)</option>
                    <option value="maze">Maze (B3/S12345)</option>
                    <option value="anneal">Anneal (B4678/S35678)</option>
                    <option value="custom" style="font-weight:bold; color:#ffcc00;">üõ†Ô∏è Egy√©ni Szab√°ly...</option>
                </select>

                <!-- EGY√âNI SZAB√ÅLY SZERKESZT≈ê (Alapb√≥l rejtve) -->
                <div id="customRuleEditor" style="display:none; background:#333; padding:8px; border-radius:4px; margin-top:5px; border:1px solid #555;">
                    <div style="font-size:0.75rem; color:#bbb; margin-bottom:4px;">SZ√úLET√âS (Born): H√°ny szomsz√©dn√°l?</div>
                    <div class="bit-selector" id="bornSelector"></div>
                    <div style="font-size:0.75rem; color:#bbb; margin:6px 0 4px 0;">T√öL√âL√âS (Survive): H√°ny szomsz√©dn√°l?</div>
                    <div class="bit-selector" id="surviveSelector"></div>
                    <div id="ruleNameDisplay" style="text-align:center; font-size:0.8rem; color:#00ffaa; margin-top:5px;">B3/S23</div>
                </div>            
                
                <div style="margin-top:8px; border-top:1px solid #444; padding-top:8px;">
                    <label>Sz√≠nez√©si M√≥d</label>
                    <select id="colorMode" onchange="onColorModeChange()">
                        <option value="static">Statikus (Alap)</option>
                        <option value="trail">Ut√≥h√∫z√°s (Trail)</option>
                        <option value="age">√âletkor (Age)</option>
                    </select>
                </div>

                <div class="gol-controls">
                    <button class="gol-btn" id="btnStart" onclick="toggleLife()" style="background: #28a745;">Start</button>
                    <button class="gol-btn" onclick="stepLifeManual()" style="background: #ffc107; color: #000;">L√©p√©s</button>
                    <button class="gol-btn" onclick="resetLife()" style="background: #17a2b8;">Reset</button>
                </div>
                <button class="gol-btn" onclick="clearScreen()" style="background: #d63384; margin-top:5px; width:100%;">T√∂rl√©s (Clear)</button>
            </div>
        </div>

        <!-- SECTION 4.5: RAJZESZK√ñZ√ñK (√Åthelyezve) -->
        <div class="control-section">
            <div class="section-header" onclick="toggleSection(this)">Rajzeszk√∂z√∂k <span class="arrow">‚ñº</span></div>
            <div class="section-content">
                <div class="drawing-tools">
                    <button class="tool-btn active" id="tool-pencil" onclick="setTool('pencil')" title="Ceruza (Shift+Klikk)">‚úèÔ∏è</button>
                    <button class="tool-btn" id="tool-eraser" onclick="setTool('eraser')" title="Rad√≠r">üßπ</button>
                    <button class="tool-btn" id="tool-square" onclick="setTool('square')" title="T√©glalap">‚¨ú</button>
                    <button class="tool-btn" id="tool-line" onclick="setTool('line')" title="Szakasz">üìè</button>
                    <button class="tool-btn" id="tool-circle" onclick="setTool('circle')" title="K√∂r">‚≠ï</button>
                </div>
                <div class="helper-text" style="margin-top:8px;">SHIFT nyomvatart√°sa mellett rajzolhatsz a v√°szonra.</div>
            </div>
        </div>

        <!-- SECTION 5: M≈∞VELETEK & PROJEKT -->
        <div class="control-section">
            <div class="section-header" onclick="toggleSection(this)">M≈±veletek <span class="arrow">‚ñº</span></div>
            <div class="section-content">
                <div class="stats">Pixel db: <span id="matchCount">0</span></div>
                <div class="helper-text" style="margin-bottom:10px;">SHIFT + Klikk: Pixel invert√°l√°sa</div>
                
                <button class="secondary-btn delete-all-btn" onclick="deleteAllLayers()">Minden t√∂rl√©se</button>
                <button class="secondary-btn" onclick="saveImage()">K√©p ment√©se (PNG)</button>
                
                <div style="margin-top:15px; border-top:1px solid #444; padding-top:10px;">
                    <label>Projekt Ment√©s / Bet√∂lt√©s</label>
                    <button class="secondary-btn" onclick="exportConfig()" style="background:#555; margin-bottom:5px;">Ment√©s F√°jlba (JSON)</button>
                    <button class="secondary-btn" onclick="document.getElementById('fileInput').click()" style="background:#555;">Bet√∂lt√©s F√°jlb√≥l</button>
                    <input type="file" id="fileInput" style="display:none" onchange="importConfig(this)" accept=".json">
                </div>
                
                <div style="margin-top:10px; border-top:1px solid #444; padding-top:10px;">
                     <button class="secondary-btn" onclick="pasteFromClipboard()" style="background:#007bff;">üìã Beilleszt√©s V√°g√≥lapr√≥l</button>
                     <div class="helper-text">K√©p konvert√°l√°sa 1-bites grafik√°v√°</div>
                </div>
            </div>
        </div>

    </div>

    <button class="sidebar-toggle" onclick="toggleSidebar()" title="Vez√©rl≈ëpanel elrejt√©se/megjelen√≠t√©se">
        <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none"><path d="M3 12h18M3 6h18M3 18h18"/></svg>
    </button>

    <div class="canvas-container">
        <canvas id="ulamCanvas" width="1001" height="1001"></canvas>
        <div class="canvas-controls">
            <button class="canvas-btn" onclick="zoomCanvas(1.2)" title="Nagy√≠t√°s">+</button>
            <button class="canvas-btn" onclick="zoomCanvas(0.8)" title="Kicsiny√≠t√©s">-</button>
            <button class="canvas-btn" onclick="fitToScreen()" title="K√©perny≈ëre igaz√≠t√°s">‚ü≤</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('ulamCanvas');
        const container = document.querySelector('.canvas-container');
        const ctx = canvas.getContext('2d');
        const countSpan = document.getElementById('matchCount');
        const layerListDiv = document.getElementById('layerList');
        const infoPos = document.getElementById('infoPos');
        const infoIdx = document.getElementById('infoIdx');
        const infoVal = document.getElementById('infoVal');
        const btnStart = document.getElementById('btnStart');

        let GRID_SIZE = 1001;
        let TOTAL_ITEMS = GRID_SIZE * GRID_SIZE; 
        let CX = Math.floor(GRID_SIZE / 2);
        let CY = Math.floor(GRID_SIZE / 2);

        let layers = []; 
        let manualEdits = new Map(); 
        let timeoutId;
        let lifeInterval = null;
        let isPaused = false;
        let lifeGrid = new Uint8Array(TOTAL_ITEMS);
        let nextGrid = new Uint8Array(TOTAL_ITEMS);
        let displayGrid = new Float32Array(TOTAL_ITEMS); // Ut√≥h√∫z√°s megjelen√≠t√©shez
        let ageGrid = new Uint32Array(TOTAL_ITEMS);      // √âletkor t√°rol√°s√°hoz
        let scale = 1, translateX = 0, translateY = 0;
        let panning = false, startX = 0, startY = 0;

        // RAJZOL√ÅS √ÅLLAPOT
        let currentTool = 'pencil';
        let isDrawing = false;
        let shapeStart = null; // {x, y}
        let previewPixels = new Map(); // index -> 1

        // --- MATEMATIKA ---
        function isPrime(num) {
            if (num <= 1) return false;
            if (num <= 3) return true;
            if (num % 2 === 0 || num % 3 === 0) return false;
            let i = 5;
            while (i * i <= num) {
                if (num % i === 0 || num % (i + 2) === 0) return false;
                i += 6;
            }
            return true;
        }
        function isSquare(num) { if(num<0)return false; const s=Math.sqrt(num); return Math.round(s)**2===num; }
        function isCube(num) { const c=Math.cbrt(num); return Math.round(c)**3===num; }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [255, 255, 255];
        }

        // --- JAV√çTOTT ULAM INDEX SZ√ÅM√çT√ÅS ---
        function getUlamIndex(gx, gy) {
            let x = gx - CX;
            let y = -(gy - CY); 
            if (x === 0 && y === 0) return 0;
            const k = Math.max(Math.abs(x), Math.abs(y)); 
            if (x === k && y > -k) return (2*k-1)**2 + (y + k - 1);
            if (y === k && x >= -k) return ((2*k-1)**2) + (2*k - 1) + (k - x);
            if (x === -k && y < k) return ((2*k-1)**2) + (4*k - 1) + (k - y);
            if (y === -k && x > -k) return ((2*k-1)**2) + (6*k - 1) + (x + k);
            return 0;
        }

        function getLinearIndex(gx, gy) {
            return gy * GRID_SIZE + gx;
        }

        function getCanvasCoordinates(e) {
            const rect = container.getBoundingClientRect();
            const clientX = e.clientX;
            const clientY = e.clientY;
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;
            const rawX = (mouseX - translateX) / scale;
            const rawY = (mouseY - translateY) / scale;
            const x = Math.floor(rawX);
            const y = Math.floor(rawY);
            return { x, y, valid: x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE };
        }

        // --- UI ---
        function getInputs() {
            const layoutMode = document.querySelector('input[name="layoutMode"]:checked') ? document.querySelector('input[name="layoutMode"]:checked').value : 'spiral';
            return {
                start: parseInt(document.getElementById('startValue').value) || 0,
                incr: parseInt(document.getElementById('increment').value) || 1,
                mode: document.querySelector('input[name="ulamMode"]:checked').value,
                color: document.getElementById('layerColor').value,
                layout: layoutMode
            };
        }

        function onColorChange() {
            if (lifeInterval || isPaused) renderLifeFrame();
            else drawSpiral();
        }

        function drawSpiral() {
            if (lifeInterval || isPaused) return; 
            if (timeoutId) clearTimeout(timeoutId);
            timeoutId = setTimeout(render, 15);
        }

        function addLayer() {
            const current = getInputs();
            const rgb = hexToRgb(current.color);
            layers.push({ ...current, visible: true, rgb: rgb });
            updateLayerListUI();
            drawSpiral();
        }

        function updateLayerListUI() {
            layerListDiv.innerHTML = '';
            layers.forEach((l, idx) => {
                let label = l.mode === 'step' ? `Szekv.: ${l.start} + ${l.incr}n` :
                            l.mode === 'prime' ? `Pr√≠m (${l.start})` :
                            l.mode === 'square' ? `N√©gyzet (${l.start})` : `K√∂b (${l.start})`;
                const div = document.createElement('div');
                div.className = `layer-item ${l.visible ? '' : 'hidden-layer'}`;
                div.style.borderLeftColor = l.color;
                div.innerHTML = `
                    <div class="layer-info" title="${label}"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${l.color};margin-right:8px;"></span><span>${label}</span></div>
                    <div class="layer-controls"><button class="icon-btn" onclick="toggleLayerVis(${idx})">${l.visible?'üëÅÔ∏è':'üö´'}</button><button class="icon-btn btn-delete" onclick="delLayer(${idx})">üóëÔ∏è</button></div>`;
                layerListDiv.appendChild(div);
            });
        }

        function toggleLayerVis(i) { layers[i].visible = !layers[i].visible; drawSpiral(); updateLayerListUI(); }
        function delLayer(i) { layers.splice(i, 1); drawSpiral(); updateLayerListUI(); }
        function deleteAllLayers() { if (confirm("Biztosan t√∂r√∂lsz mindent?")) { layers = []; manualEdits.clear(); resetLife(); updateLayerListUI(); } }
        function saveImage() { const link = document.createElement('a'); link.download = 'ulam_spiral.png'; link.href = canvas.toDataURL(); link.click(); }

        async function pasteFromClipboard() {
            try {
                const items = await navigator.clipboard.read();
                for (const item of items) {
                    const type = item.types.find(t => t.startsWith('image/'));
                    if (type) {
                        const blob = await item.getType(type);
                        const img = new Image();
                        img.onload = () => processPastedImage(img);
                        img.src = URL.createObjectURL(blob);
                        return;
                    }
                }
                alert("Nem tal√°lhat√≥ k√©p a v√°g√≥lapon!");
            } catch (err) {
                console.error(err);
                alert("Hiba a beilleszt√©s sor√°n: " + err.message + "\n(Lehet, hogy a b√∂ng√©sz≈ë nem enged√©lyezi?)");
            }
        }

        function processPastedImage(img) {
            // Off-screen canvas a feldolgoz√°shoz
            const offCanvas = document.createElement('canvas');
            const w = img.width;
            const h = img.height;
            
            // Limit m√©ret, ha t√∫l nagy
            const MAX_SIDE = GRID_SIZE; 
            let drawW = w, drawH = h;
            if (w > MAX_SIDE || h > MAX_SIDE) {
                const ratio = Math.min(MAX_SIDE / w, MAX_SIDE / h);
                drawW = Math.floor(w * ratio);
                drawH = Math.floor(h * ratio);
            }

            offCanvas.width = drawW;
            offCanvas.height = drawH;
            const offCtx = offCanvas.getContext('2d');
            offCtx.drawImage(img, 0, 0, drawW, drawH);
            
            const imgData = offCtx.getImageData(0, 0, drawW, drawH);
            const data = imgData.data;
            
            // K√∂z√©pre igaz√≠t√°s
            const startX = Math.floor((GRID_SIZE - drawW) / 2);
            const startY = Math.floor((GRID_SIZE - drawH) / 2);

            let addedCount = 0;
            const isSimulating = lifeInterval || isPaused;

            for (let y = 0; y < drawH; y++) {
                for (let x = 0; x < drawW; x++) {
                    const i = (y * drawW + x) * 4;
                    const r = data[i];
                    const g = data[i+1];
                    const b = data[i+2];
                    const a = data[i+3]; // Alpha

                    // Luminancia alap√∫ k√ºsz√∂b√∂l√©s (1-bit konverzi√≥)
                    // (0.299*R + 0.587*G + 0.114*B)
                    const lum = 0.299*r + 0.587*g + 0.114*b;
                    
                    // Ha el√©g vil√°gos √©s nem √°tl√°tsz√≥ -> 1 (Alive)
                    // VAGY ha a felhaszn√°l√≥ fekete rajzot akar feh√©r alapon?
                    // Ulam lab alapja fekete. Teh√°t a vil√°gos pixelek legyenek akt√≠vak.
                    if (a > 128 && lum > 100) {
                        const targetX = startX + x;
                        const targetY = startY + y;
                        
                        if (targetX >= 0 && targetX < GRID_SIZE && targetY >= 0 && targetY < GRID_SIZE) {
                            const idx = targetY * GRID_SIZE + targetX;
                            if (isSimulating) {
                                lifeGrid[idx] = 1;
                            } else {
                                manualEdits.set(idx, 1);
                            }
                            addedCount++;
                        }
                    }
                }
            }
            
            if (isSimulating && isPaused) renderLifeFrame();
            else if (!isSimulating) render();
            
            alert(`Sikeres beilleszt√©s! ${addedCount} pixel hozz√°adva.`);
        }

        // --- ESEM√âNYKEZEL√âS (√öJRAGONDOLVA) ---
        
        // 1. Mouse Down
        container.addEventListener('mousedown', (e) => { 
            if (e.button !== 0) return; // Csak bal klikk
            
            if (e.shiftKey) {
                isDrawing = true;
                const pos = getCanvasCoordinates(e);
                if (!pos.valid) { isDrawing = false; return; }

                if (currentTool === 'pencil' || currentTool === 'eraser') {
                    handlePencil(pos);
                } else {
                    // Shape start
                    shapeStart = pos;
                    previewPixels.clear();
                }
            } else {
                // Panning
                panning = true; 
                startX = e.clientX - translateX; 
                startY = e.clientY - translateY; 
                container.style.cursor = "grabbing";
            }
        });

        // 2. Mouse Move
        window.addEventListener('mousemove', (e) => { 
            updateStatusPanel(e);
            
            if (panning) { 
                e.preventDefault(); 
                translateX = e.clientX - startX; 
                translateY = e.clientY - startY; 
                applyTransform(); 
                return;
            }

            if (isDrawing && e.shiftKey) { // Csak ha Shift m√©g nyomva van (biztons√°g)
                const pos = getCanvasCoordinates(e);
                if (!pos.valid) return;

                if (currentTool === 'pencil' || currentTool === 'eraser') {
                    handlePencil(pos);
                } else {
                    // Shape Preview
                    calculateShapePreview(pos);
                    render(); // √öjrarajzol√°s preview-val
                }
            }
        });

        // 3. Mouse Up
        window.addEventListener('mouseup', () => { 
            if (isDrawing && currentTool !== 'pencil' && currentTool !== 'eraser' && shapeStart) {
                // Commit Shape
                commitShape();
                render();
            }
            
            isDrawing = false; 
            panning = false; 
            shapeStart = null;
            previewPixels.clear();
            container.style.cursor = "crosshair"; 
            
            // Ha volt preview, el kell t≈±ntetni (ha a commitShape nem h√≠vott render-t)
            // De commitShape h√≠vott. Ha m√©gse (pl. √©rv√©nytelen), akkor renderelni kell, hogy elt≈±nj√∂n a preview.
            // Biztons√°gb√≥l renderelhet√ºnk, ha volt shapeStart.
        });
        
        container.addEventListener('mouseleave', () => resetStatusPanel());

        function resetStatusPanel() { infoPos.textContent = "-"; infoIdx.textContent = "-"; infoVal.textContent = "-"; }
        function updateStatusPanel(e) {
            const pos = getCanvasCoordinates(e);
            if (pos.valid) {
                const relX = pos.x - CX; const relY = -(pos.y - CY); 
                const inputs = getInputs(); 
                let idx, valText;
                
                // Csak Ulam √©s Linear m√≥dn√°l tudjuk pontosan visszafejteni az indexet a r√°cspontb√≥l
                if (inputs.layout === 'linear') {
                    idx = getLinearIndex(pos.x, pos.y);
                    const val = inputs.start + (idx * inputs.incr);
                    valText = val.toLocaleString();
                    infoIdx.textContent = idx.toLocaleString();
                } else if (inputs.layout === 'spiral') {
                    idx = getUlamIndex(pos.x, pos.y);
                    const val = inputs.start + (idx * inputs.incr);
                    valText = val.toLocaleString();
                    infoIdx.textContent = idx.toLocaleString();
                } else {
                    // Sacks/Vogel eset√©n ez nem trivi√°lis (k√∂zel√≠t√©s kellene)
                    idx = "-";
                    valText = "-";
                    infoIdx.textContent = "N/A";
                }
                
                infoPos.textContent = `X:${relX} Y:${relY}`; 
                infoVal.textContent = valText;
            } else { resetStatusPanel(); }
        }

        // Eszk√∂z v√°laszt√°s
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('tool-' + tool).classList.add('active');
        }

        function handlePencil(pos) {
            const idx = pos.y * GRID_SIZE + pos.x;
            
            if (currentTool === 'eraser') {
                 if (lifeInterval || isPaused) { 
                    lifeGrid[idx] = 0; 
                    if (isPaused) renderLifeFrame(); 
                } else { 
                    manualEdits.delete(idx);
                    render(); 
                }
            } else {
                if (lifeInterval || isPaused) { 
                    lifeGrid[idx] = 1; 
                    if (isPaused) renderLifeFrame(); 
                } else { 
                    manualEdits.set(idx, 1); 
                    render(); 
                }
            }
        }

        function calculateShapePreview(endPos) {
            previewPixels.clear();
            if (!shapeStart) return;

            const x0 = shapeStart.x; const y0 = shapeStart.y;
            const x1 = endPos.x; const y1 = endPos.y;

            if (currentTool === 'line') {
                // Bresenham line
                let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
                let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
                let err = dx + dy, e2;
                let cx = x0, cy = y0;
                while (true) {
                    if (cx >= 0 && cx < GRID_SIZE && cy >= 0 && cy < GRID_SIZE) {
                        previewPixels.set(cy * GRID_SIZE + cx, 1);
                    }
                    if (cx === x1 && cy === y1) break;
                    e2 = 2 * err;
                    if (e2 >= dy) { err += dy; cx += sx; }
                    if (e2 <= dx) { err += dx; cy += sy; }
                }
            } 
            else if (currentTool === 'square') {
                const minX = Math.min(x0, x1), maxX = Math.max(x0, x1);
                const minY = Math.min(y0, y1), maxY = Math.max(y0, y1);
                
                // Top & Bottom
                for (let x = minX; x <= maxX; x++) {
                    if (x >= 0 && x < GRID_SIZE) {
                        if (minY >= 0 && minY < GRID_SIZE) previewPixels.set(minY * GRID_SIZE + x, 1);
                        if (maxY >= 0 && maxY < GRID_SIZE) previewPixels.set(maxY * GRID_SIZE + x, 1);
                    }
                }
                // Left & Right
                for (let y = minY; y <= maxY; y++) {
                    if (y >= 0 && y < GRID_SIZE) {
                        if (minX >= 0 && minX < GRID_SIZE) previewPixels.set(y * GRID_SIZE + minX, 1);
                        if (maxX >= 0 && maxX < GRID_SIZE) previewPixels.set(y * GRID_SIZE + maxX, 1);
                    }
                }
            }
            else if (currentTool === 'circle') {
                const r = Math.sqrt((x1-x0)**2 + (y1-y0)**2);
                const rCeil = Math.ceil(r);
                for (let y = y0 - rCeil; y <= y0 + rCeil; y++) {
                    for (let x = x0 - rCeil; x <= x0 + rCeil; x++) {
                        const dist = Math.sqrt((x-x0)**2 + (y-y0)**2);
                        // Outline logic: distance approx radius (within 0.8px)
                        if (Math.abs(dist - r) < 0.8) {
                            if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                                previewPixels.set(y * GRID_SIZE + x, 1);
                            }
                        }
                    }
                }
            }
        }

        function commitShape() {
            // Apply previewPixels to manualEdits (or lifeGrid)
            if (lifeInterval || isPaused) {
                previewPixels.forEach((_, idx) => {
                    lifeGrid[idx] = 1; // Always ADD shape to life
                });
                if (isPaused) renderLifeFrame();
            } else {
                previewPixels.forEach((_, idx) => {
                    manualEdits.set(idx, 1); // Always ADD shape
                });
            }
        }

        function render() {
            const current = getInputs(); const currentRgb = hexToRgb(current.color);
            const imgData = ctx.createImageData(GRID_SIZE, GRID_SIZE); const data = imgData.data;
            const layout = current.layout;

            const showLayers = current.mode !== 'empty';
            const queue = []; 
            
            if (showLayers) {
                layers.forEach(l => { if(l.visible) queue.push(l); }); 
                queue.push({ ...current, isPreview: true, rgb: currentRgb });
            }

            // Init coords based on layout
            let sx = 0, sy = 0, dx = 1, dy = 0, segmentLength = 1, segmentPassed = 0, turnCount = 0;
            let lx = 0, ly = 0;

            // Scaling for continuous spirals
            // Max radius = min(GRID_SIZE/2, 500)
            const maxRadius = Math.min(GRID_SIZE/2, 500);
            const maxN = TOTAL_ITEMS;
            const mathMaxR = Math.sqrt(maxN); // Sacks & Vogel both scale with sqrt(n)
            const scaleFactor = maxRadius / mathMaxR;
            const vogelAngle = 2.39996323; // Golden angle in radians

            let count = 0;
            for (let i = 0; i < TOTAL_ITEMS; i++) {
                let cx, cy;

                if (layout === 'linear') {
                    cx = lx; 
                    cy = ly;
                } else if (layout === 'spiral') {
                    cx = CX + sx; 
                    cy = CY - sy;
                } else if (layout === 'sacks') {
                    // Sacks Spiral: r = sqrt(i), theta = 2*PI*sqrt(i)
                    const r = Math.sqrt(i) * scaleFactor;
                    const theta = 2 * Math.PI * Math.sqrt(i);
                    // Align squares on positive x axis? Usually they spiral out.
                    // Let's use standard formula.
                    cx = Math.round(CX + r * Math.cos(theta));
                    cy = Math.round(CY - r * Math.sin(theta));
                } else if (layout === 'vogel') {
                    // Vogel Spiral: r = c*sqrt(i), theta = i * 137.5 deg
                    const r = Math.sqrt(i) * scaleFactor;
                    const theta = i * vogelAngle;
                    cx = Math.round(CX + r * Math.cos(theta));
                    cy = Math.round(CY - r * Math.sin(theta));
                }

                // Check bounds just in case (though loop ensures validity)
                if (cx >= 0 && cx < GRID_SIZE && cy >= 0 && cy < GRID_SIZE) {
                    const pixelIndex = (cy * GRID_SIZE + cx) * 4; 
                    const manualIdx = cy * GRID_SIZE + cx;
                    let r=0, g=0, b=0, a=0;
                    
                    if (showLayers) {
                        for (let l = 0; l < queue.length; l++) {
                            const layer = queue[l]; let isMatch = false;
                            if (layer.mode === 'step') { if (i >= layer.start && (i - layer.start) % layer.incr === 0) isMatch = true; }
                            else { const val = layer.start + (i * layer.incr); if (layer.mode === 'prime') isMatch = isPrime(val); else if (layer.mode === 'square') isMatch = isSquare(val); else if (layer.mode === 'cube') isMatch = isCube(val); }
                            if (isMatch) { r = layer.rgb[0]; g = layer.rgb[1]; b = layer.rgb[2]; a = 255; }
                        }
                    }

                    if (manualEdits.has(manualIdx)) { if (a === 0) { r=255; g=255; b=255; a=255; } else { r=0; g=0; b=0; a=255; } }
                    
                    // PREVIEW LAYER
                    if (previewPixels.has(manualIdx)) {
                        r = 0; g = 255; b = 0; a = 255;
                    }

                    if (a > 0) { data[pixelIndex] = r; data[pixelIndex+1] = g; data[pixelIndex+2] = b; data[pixelIndex+3] = a; count++; }
                }

                // Advance coordinates
                if (i < TOTAL_ITEMS - 1) { 
                    if (layout === 'linear') {
                        lx++;
                        if (lx >= GRID_SIZE) { lx = 0; ly++; }
                    } else if (layout === 'spiral') {
                        sx += dx; sy += dy; segmentPassed++; 
                        if (segmentPassed === segmentLength) { segmentPassed = 0; const tempDx = dx; dx = -dy; dy = tempDx; turnCount++; if (turnCount % 2 === 0) segmentLength++; } 
                    }
                    // Sacks/Vogel use direct calculation from 'i', no incremental state needed
                }
            }
            ctx.putImageData(imgData, 0, 0); 
            // Center point visual aid (not for Linear)
            if (layout !== 'linear') {
                ctx.fillStyle = 'white'; ctx.fillRect(CX, CY, 1, 1);
            }
            countSpan.textContent = count.toLocaleString();
        }

        function toggleLife() { if (lifeInterval) pauseLife(); else if (isPaused) resumeLife(); else initLife(); }
        function initLife() {
            const current = getInputs(); const currentRgb = hexToRgb(current.color);
            const showLayers = current.mode !== 'empty';
            const layout = current.layout;
            
            const queue = []; 
            if (showLayers) {
                layers.forEach(l => { if(l.visible) queue.push(l); }); 
                queue.push({ ...current, rgb: currentRgb });
            }

            lifeGrid.fill(0);
            displayGrid.fill(0); // Reset Trail
            ageGrid.fill(0);     // Reset Age
            
            let sx = 0, sy = 0, dx = 1, dy = 0, segmentLength = 1, segmentPassed = 0, turnCount = 0;
            let lx = 0, ly = 0;

            const maxRadius = Math.min(GRID_SIZE/2, 500);
            const scaleFactor = maxRadius / Math.sqrt(TOTAL_ITEMS);
            const vogelAngle = 2.39996323;

            for (let i = 0; i < TOTAL_ITEMS; i++) {
                let cx, cy;
                
                if (layout === 'linear') {
                    cx = lx; cy = ly;
                } else if (layout === 'spiral') {
                    cx = CX + sx; cy = CY - sy;
                } else if (layout === 'sacks') {
                    const r = Math.sqrt(i) * scaleFactor;
                    const theta = 2 * Math.PI * Math.sqrt(i);
                    cx = Math.round(CX + r * Math.cos(theta));
                    cy = Math.round(CY - r * Math.sin(theta));
                } else if (layout === 'vogel') {
                    const r = Math.sqrt(i) * scaleFactor;
                    const theta = i * vogelAngle;
                    cx = Math.round(CX + r * Math.cos(theta));
                    cy = Math.round(CY - r * Math.sin(theta));
                }

                if (cx >= 0 && cx < GRID_SIZE && cy >= 0 && cy < GRID_SIZE) {
                    let isAlive = 0;
                    if (showLayers) {
                        for (let l = 0; l < queue.length; l++) {
                            const layer = queue[l];
                            if (layer.mode === 'step') { if (i >= layer.start && (i - layer.start) % layer.incr === 0) isAlive = 1; }
                            else { const val = layer.start + (i * layer.incr); if (layer.mode === 'prime' && isPrime(val)) isAlive = 1; else if (layer.mode === 'square' && isSquare(val)) isAlive = 1; else if (layer.mode === 'cube' && isCube(val)) isAlive = 1; }
                            if (isAlive) break;
                        }
                    }
                    const idx = cy * GRID_SIZE + cx; 
                    if (manualEdits.has(idx)) isAlive = isAlive ? 0 : 1; 
                    lifeGrid[idx] = isAlive;
                    if (isAlive) { displayGrid[idx] = 255; ageGrid[idx] = 1; }
                }

                if (i < TOTAL_ITEMS - 1) { 
                    if (layout === 'linear') { lx++; if (lx >= GRID_SIZE) { lx = 0; ly++; } }
                    else if (layout === 'spiral') { sx += dx; sy += dy; segmentPassed++; if (segmentPassed === segmentLength) { segmentPassed = 0; const tempDx = dx; dx = -dy; dy = tempDx; turnCount++; if (turnCount % 2 === 0) segmentLength++; } }
                }
            }
            resumeLife();
        }
        function pauseLife() { clearInterval(lifeInterval); lifeInterval = null; isPaused = true; btnStart.textContent = "Folytat√°s"; btnStart.style.background = "#28a745"; }
        function resumeLife() { isPaused = false; btnStart.textContent = "Sz√ºnet"; btnStart.style.background = "#ffc107"; btnStart.style.color = "#000"; lifeInterval = setInterval(stepLife, 100); }
        function resetLife() { pauseLife(); isPaused = false; btnStart.textContent = "Start"; btnStart.style.background = "#28a745"; btnStart.style.color = "#fff"; render(); }
        function clearScreen() {
            pauseLife();
            isPaused = false;
            btnStart.textContent = "Start"; 
            btnStart.style.background = "#28a745"; 
            btnStart.style.color = "#fff";
            
            lifeGrid.fill(0);
            displayGrid.fill(0);
            ageGrid.fill(0);
            manualEdits.clear();
            
            renderLifeFrame();
        }

        const LIFE_RULES = {
            life:           { b: 1<<3, s: (1<<2)|(1<<3) },
            highlife:       { b: (1<<3)|(1<<6), s: (1<<2)|(1<<3) },
            daynight:       { b: (1<<3)|(1<<6)|(1<<7)|(1<<8), s: (1<<3)|(1<<4)|(1<<6)|(1<<7)|(1<<8) },
            seeds:          { b: 1<<2, s: 0 },
            diamoeba:       { b: (1<<3)|(1<<5)|(1<<6)|(1<<7)|(1<<8), s: (1<<5)|(1<<6)|(1<<7)|(1<<8) },
            morley:         { b: (1<<3)|(1<<6)|(1<<8), s: (1<<2)|(1<<4)|(1<<5) },
            // √öjak:
            replicator:     { b: (1<<1)|(1<<3)|(1<<5)|(1<<7), s: (1<<1)|(1<<3)|(1<<5)|(1<<7) },
            walledcities:   { b: (1<<4)|(1<<5)|(1<<6)|(1<<7)|(1<<8), s: (1<<2)|(1<<3)|(1<<4)|(1<<5) },
            stains:         { b: (1<<3)|(1<<6)|(1<<7)|(1<<8), s: (1<<2)|(1<<3)|(1<<5)|(1<<6)|(1<<7)|(1<<8) },
            maze:           { b: 1<<3, s: (1<<1)|(1<<2)|(1<<3)|(1<<4)|(1<<5) },
            anneal:         { b: (1<<4)|(1<<6)|(1<<7)|(1<<8), s: (1<<3)|(1<<5)|(1<<6)|(1<<7)|(1<<8) }
        };

        let lastLifeRule = 'life';

        // Init checkboxok gener√°l√°sa (0-t√≥l 8-ig)
        function initRuleEditor() {
            const bSel = document.getElementById('bornSelector');
            const sSel = document.getElementById('surviveSelector');
            
            for(let i=0; i<=8; i++) {
                // Born
                bSel.innerHTML += `
                    <input type="checkbox" id="b${i}" class="bit-chk" onchange="updateRuleString()">
                    <label for="b${i}" class="bit-label">${i}</label>
                `;
                // Survive
                sSel.innerHTML += `
                    <input type="checkbox" id="s${i}" class="bit-chk" onchange="updateRuleString()">
                    <label for="s${i}" class="bit-label">${i}</label>
                `;
            }
        }
        // H√≠vjuk meg az oldal bet√∂lt√©sekor!
        initRuleEditor();

        function toggleRuleEditor() {
            const val = document.getElementById('lifeRule').value;
            const editor = document.getElementById('customRuleEditor');
            
            if (val === 'custom') {
                editor.style.display = 'block';
                // Bet√∂ltj√ºk az el≈ëz≈ë szab√°ly be√°ll√≠t√°sait alapnak
                const rule = LIFE_RULES[lastLifeRule] || LIFE_RULES.life;
                for(let i=0; i<=8; i++) {
                    document.getElementById(`b${i}`).checked = (rule.b >> i) & 1;
                    document.getElementById(`s${i}`).checked = (rule.s >> i) & 1;
                }
                updateRuleString();
            } else {
                editor.style.display = 'none';
                lastLifeRule = val;
            }
        }

        function updateRuleString() {
            let bStr = "", sStr = "";
            for(let i=0; i<=8; i++) {
                if(document.getElementById(`b${i}`).checked) bStr += i;
                if(document.getElementById(`s${i}`).checked) sStr += i;
            }
            document.getElementById('ruleNameDisplay').textContent = `B${bStr}/S${sStr}`;
        }

        function onColorModeChange() {
            const mode = document.getElementById('colorMode').value;
            if (mode === 'trail') {
                for(let i=0; i<TOTAL_ITEMS; i++) {
                    displayGrid[i] = lifeGrid[i] ? 255 : 0;
                }
            }
            renderLifeFrame();
        }

        // Seg√©df√ºggv√©ny a Custom szab√°ly kinyer√©s√©re
        function getCustomRuleMasks() {
            let b = 0, s = 0;
            for(let i=0; i<=8; i++) {
                if(document.getElementById(`b${i}`).checked) b |= (1 << i);
                if(document.getElementById(`s${i}`).checked) s |= (1 << i);
            }
            return { b, s };
        }

        function stepLifeManual() {
            if (lifeInterval) {
                pauseLife();
            }
            stepLife();
        }

        function stepLife() {
            const ruleKey = document.getElementById('lifeRule').value;
            let rule;

            if (ruleKey === 'custom') {
                rule = getCustomRuleMasks(); // Checkboxokb√≥l olvassuk ki
            } else {
                rule = LIFE_RULES[ruleKey] || LIFE_RULES.life;
            }
            
            nextGrid.fill(0);
            for (let y = 1; y < GRID_SIZE - 1; y++) {
                let rowOffset = y * GRID_SIZE;
                for (let x = 1; x < GRID_SIZE - 1; x++) {
                    const idx = rowOffset + x;
                    let neighbors = lifeGrid[idx - GRID_SIZE - 1] + lifeGrid[idx - GRID_SIZE] + lifeGrid[idx - GRID_SIZE + 1] + lifeGrid[idx - 1] + lifeGrid[idx + 1] + lifeGrid[idx + GRID_SIZE - 1] + lifeGrid[idx + GRID_SIZE] + lifeGrid[idx + GRID_SIZE + 1];

                    const cell = lifeGrid[idx];
                    // Haszn√°ljuk a maszkokat
                    if (cell === 1) { 
                        if ((rule.s >> neighbors) & 1) nextGrid[idx] = 1; 
                    } else { 
                        if ((rule.b >> neighbors) & 1) nextGrid[idx] = 1; 
                    }
                }
            }
            // ... swap √©s renderel√©s ...
            let temp = lifeGrid; lifeGrid = nextGrid; nextGrid = temp;
            
            // Friss√≠ts√ºk az extra r√°csokat (Trail √©s Age)
            for (let i = 0; i < TOTAL_ITEMS; i++) {
                if (lifeGrid[i] === 1) {
                    displayGrid[i] = 255;
                    ageGrid[i]++; // N√∂velj√ºk a kort
                } else {
                    displayGrid[i] = Math.max(0, displayGrid[i] * 0.9); // Cs√∂kkentj√ºk a f√©nyer≈ët
                    ageGrid[i] = 0; // Resetelj√ºk a kort
                }
            }

            renderLifeFrame();
        }

        function renderLifeFrame() {
            const imgData = ctx.createImageData(GRID_SIZE, GRID_SIZE); const data = imgData.data;
            const colorInput = document.getElementById('layerColor').value; const baseRgb = hexToRgb(colorInput);
            const mode = document.getElementById('colorMode').value;
            let count = 0;

            for (let i = 0; i < TOTAL_ITEMS; i++) {
                const idx = i * 4;
                let r = 0, g = 0, b = 0, a = 0;

                if (mode === 'static') {
                    if (lifeGrid[i]) {
                        r = baseRgb[0]; g = baseRgb[1]; b = baseRgb[2]; a = 255;
                        count++;
                    }
                } 
                else if (mode === 'trail') {
                    const val = displayGrid[i];
                    if (val > 1) { // Csak ha l√°that√≥
                       
                        const intensity = val / 255;
                       
                        r = baseRgb[0] * intensity;
                        g = baseRgb[1] * (intensity * intensity); // Gyorsabb s√∂t√©ted√©s = sz√≠n eltol√≥d√°s
                        b = baseRgb[2] * (intensity * intensity * intensity);
                        a = 255;
                        
                        if (lifeGrid[i]) count++;
                    }
                }
                else if (mode === 'age') {
                    if (lifeGrid[i]) {
                        const age = ageGrid[i];
                        let h, s, l;
                        
                        // HSL konverzi√≥ logik√°ja a le√≠r√°s alapj√°n
                        if (age === 1) {
                            // √öjsz√ºl√∂tt: Feh√©r (vagy majdnem feh√©r)
                            h = 0; s = 0; l = 100; 
                        } else if (age < 10) {
                            // Fiatal: Z√∂ld (120)
                            h = 120; s = 100; l = 50;
                        } else if (age < 100) {
                            // √ñreg: K√©k (240)
                            h = 240; s = 100; l = 50;
                        } else {
                            // Matuzs√°lem: Piros (0)
                            h = 0; s = 100; l = 50;
                        }

                        // HSL to RGB konverzi√≥ (egyszer≈±s√≠tett vagy seg√©df√ºggv√©ny)
                        // Itt inline megoldjuk
                        const c = (1 - Math.abs(2 * l / 100 - 1)) * (s / 100);
                        const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
                        const m = l / 100 - c / 2;
                        let rP, gP, bP;

                        if (h < 60) { rP=c; gP=x; bP=0; }
                        else if (h < 120) { rP=x; gP=c; bP=0; }
                        else if (h < 180) { rP=0; gP=c; bP=x; }
                        else if (h < 240) { rP=0; gP=x; bP=c; }
                        else if (h < 300) { rP=x; gP=0; bP=c; }
                        else { rP=c; gP=0; bP=x; }

                        r = (rP + m) * 255;
                        g = (gP + m) * 255;
                        b = (bP + m) * 255;
                        a = 255;
                        count++;
                    }
                }

                if (a > 0) {
                    data[idx] = r; data[idx+1] = g; data[idx+2] = b; data[idx+3] = a;
                }
            }
            ctx.putImageData(imgData, 0, 0); countSpan.textContent = count.toLocaleString();
        }

        function applyTransform() { canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`; }
        function fitToScreen() { 
            const rect = container.getBoundingClientRect(); 
            // Allow scale > 1 if grid is small
            const s = Math.min((rect.width-20)/GRID_SIZE, (rect.height-20)/GRID_SIZE); 
            scale = Math.max(s, 0.1); 
            translateX = (rect.width - GRID_SIZE*scale)/2; 
            translateY = (rect.height - GRID_SIZE*scale)/2; 
            applyTransform(); 
        }
        setTimeout(fitToScreen, 100); window.addEventListener('resize', fitToScreen);
        container.addEventListener('wheel', e => { e.preventDefault(); const rect = container.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; const factor = Math.exp((e.deltaY<0?1:-1)*0.1); const nextScale = scale * factor; translateX = mx - (mx - translateX) * factor; translateY = my - (my - translateY) * factor; scale = nextScale; applyTransform(); });

        // --- √öJ GUI FUNKCI√ìK ---
        function toggleSidebar() {
            const sb = document.getElementById('sidebar');
            sb.classList.toggle('hidden');
        }

        function toggleSection(header) {
            const content = header.nextElementSibling;
            content.classList.toggle('collapsed');
        }

        function zoomCanvas(factor) {
            const rect = container.getBoundingClientRect();
            // Zoom center (screen center)
            const cx = rect.width / 2;
            const cy = rect.height / 2;
            
            const nextScale = scale * factor;
            translateX = cx - (cx - translateX) * factor;
            translateY = cy - (cy - translateY) * factor;
            scale = nextScale;
            applyTransform();
        }

        function exportConfig() {
            const config = {
                layers: layers,
                settings: getInputs(),
                lifeRule: document.getElementById('lifeRule').value,
                customRule: getCustomRuleMasks(), // Ez egy objektum {b,s}
                customRuleChecks: {
                    b: Array.from({length:9}, (_,i) => document.getElementById(`b${i}`).checked),
                    s: Array.from({length:9}, (_,i) => document.getElementById(`s${i}`).checked)
                },
                colorMode: document.getElementById('colorMode').value
            };
            const blob = new Blob([JSON.stringify(config, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ulam_projekt.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function changeGridSize(delta) {
            let newVal = parseInt(document.getElementById('gridSizeInput').value) + delta;
            if (newVal < 10) newVal = 10;
            if (newVal > 1001) newVal = 1001;
            updateGridSize(newVal);
        }

        function updateGridSize(val) {
            val = parseInt(val);
            if (isNaN(val) || val < 10) val = 10;
            if (val > 1001) val = 1001; // Limit max size if needed, or allow larger? User said 10-1001.

            if (val === GRID_SIZE) return;

            GRID_SIZE = val;
            TOTAL_ITEMS = GRID_SIZE * GRID_SIZE;
            CX = Math.floor(GRID_SIZE / 2);
            CY = Math.floor(GRID_SIZE / 2);

            // Update UI
            document.getElementById('gridSizeInput').value = val;
            document.getElementById('gridSizeSlider').value = val;

            // Resize Canvas
            canvas.width = GRID_SIZE;
            canvas.height = GRID_SIZE;

            // Reallocate Grids
            lifeGrid = new Uint8Array(TOTAL_ITEMS);
            nextGrid = new Uint8Array(TOTAL_ITEMS);
            displayGrid = new Float32Array(TOTAL_ITEMS);
            ageGrid = new Uint32Array(TOTAL_ITEMS);
            
            // Clear manual edits as indices are invalid now
            // Or try to remap? Remapping is complex (coord vs index). 
            // Clearing is safer for v1.
            manualEdits.clear(); 

            fitToScreen();
            if (lifeInterval) {
                resetLife(); // Stop simulation if running
            } else {
                drawSpiral();
            }
        }

        function importConfig(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const config = JSON.parse(e.target.result);
                    
                    // R√©tegek bet√∂lt√©se
                    if (config.layers) layers = config.layers;
                    
                    // Be√°ll√≠t√°sok bet√∂lt√©se
                    if (config.settings) {
                        document.getElementById('startValue').value = config.settings.start;
                        document.getElementById('increment').value = config.settings.incr;
                        const modeRadio = document.querySelector(`input[name="ulamMode"][value="${config.settings.mode}"]`);
                        if (modeRadio) modeRadio.checked = true;
                        // Sz√≠n nem kritikus
                    }

                    // √âletj√°t√©k szab√°lyok
                    if (config.lifeRule) {
                        document.getElementById('lifeRule').value = config.lifeRule;
                        toggleRuleEditor();
                    }
                    if (config.customRuleChecks && config.lifeRule === 'custom') {
                        config.customRuleChecks.b.forEach((chk, i) => document.getElementById(`b${i}`).checked = chk);
                        config.customRuleChecks.s.forEach((chk, i) => document.getElementById(`s${i}`).checked = chk);
                        updateRuleString();
                    }

                    // Sz√≠nez√©si m√≥d
                    if (config.colorMode) {
                        document.getElementById('colorMode').value = config.colorMode;
                    }

                    // Friss√≠t√©s
                    updateLayerListUI();
                    drawSpiral();
                    if (config.colorMode === 'trail') onColorModeChange(); // Init trail grid
                    alert("Sikeres bet√∂lt√©s!");
                } catch (err) {
                    alert("Hiba a f√°jl beolvas√°sakor: " + err);
                }
            };
            reader.readAsText(file);
            input.value = ''; // Reset input
        }

        drawSpiral();
    </script>
</body>
</html>
