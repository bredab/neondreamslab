<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moduláris Hullám Szimulátor</title>
    <style>
        :root {
            --bg-color: #050505;
            --panel-bg: #111;
            --text-color: #ccc;
            --accent-cyan: #00f3ff;
            --accent-pink: #ff00ff;
            --dot-inactive: #006064;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
        }

        h1 { margin: 0 0 10px 0; font-weight: 300; letter-spacing: 2px; color: #fff; }
        .subtitle { font-size: 14px; color: #888; margin-bottom: 20px; max-width: 600px; text-align: center; line-height: 1.5; }

        .controls {
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            width: 100%;
            max-width: 900px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column; /* Egymás alá kerülnek a csúszkák */
            gap: 15px;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.05);
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 20px;
            width: 100%;
        }

        .label-group { display: flex; flex-direction: column; min-width: 140px; }
        .label-title { font-size: 12px; color: #666; font-weight: bold; text-transform: uppercase; }
        .label-value { font-family: monospace; font-size: 24px; color: var(--accent-cyan); font-weight: bold; }

        input[type=range] {
            flex-grow: 1;
            cursor: pointer;
            accent-color: var(--accent-cyan);
            height: 6px;
            background: #333;
            border-radius: 3px;
        }

        /* INFÓ DOBOZ */
        .info-box {
            min-height: 60px;
            width: 100%;
            max-width: 900px;
            background: #0f0f15;
            border-left: 4px solid var(--accent-pink);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px 20px;
            margin-bottom: 10px;
            box-sizing: border-box;
            border-radius: 0 8px 8px 0;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .info-text {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 15px;
            color: #fff;
            width: 100%;
            text-align: left;
            line-height: 1.6;
            white-space: normal;
        }

        .info-box.visible { opacity: 1; }
        .highlight { color: var(--accent-pink); font-weight: bold; }
        .highlight-cyan { color: var(--accent-cyan); font-weight: bold; }
        .separator { color: #555; margin: 0 8px; font-weight: normal; }

        /* VIZUALIZÁCIÓ */
        .vis-container {
            position: relative;
            width: 100%;
            max-width: 900px;
            display: flex;
            flex-direction: column;
        }

        canvas {
            background: var(--panel-bg);
            border-radius: 8px 8px 0 0;
            border: 1px solid #333;
            border-bottom: none;
            cursor: crosshair;
        }

        .pixel-row-wrapper {
            background: #000;
            border: 1px solid #333;
            border-top: 1px solid #444;
            border-radius: 0 0 8px 8px;
            padding-left: 40px; 
            padding-right: 20px; 
            box-sizing: border-box;
            width: 100%;
        }

        .pixel-row {
            display: flex;
            height: 40px;
            width: 100%;
        }

        .pixel {
            flex: 1;
            border-right: 1px solid #222;
            background: #000;
            transition: background 0.1s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #333;
        }
        .pixel:last-child { border-right: none; }
        
        .pixel.active {
            background: var(--accent-pink);
            box-shadow: 0 0 15px var(--accent-pink);
            color: white;
            font-weight: bold;
            z-index: 1;
        }

        #hoverMarker {
            position: absolute;
            top: 30px; 
            bottom: 60px; 
            width: 1px;
            background: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            display: none;
            border-left: 1px dashed rgba(255,255,255,0.2);
        }

    </style>
</head>
<body>

    <h1>Moduláris Hullám Szimulátor</h1>
    <div class="subtitle">
        Állítsd be a rács méretét (N) és a hullám frekvenciáját (k)!<br>
        Figyeld meg, hogyan változik a mintázat prímszámoknál (pl. 13) és összetett számoknál (pl. 36).
    </div>

    <div class="controls">
        <!-- N Csúszka -->
        <div class="control-row">
            <div class="label-group">
                <span class="label-title">Rács Mérete (N)</span>
                <span id="valN" class="label-value">36</span>
            </div>
            <input type="range" id="inputN" min="3" max="36" step="1" value="36">
        </div>

        <!-- K Csúszka -->
        <div class="control-row">
            <div class="label-group">
                <span class="label-title">Frekvencia (k)</span>
                <span id="valK" class="label-value">1</span>
            </div>
            <input type="range" id="inputK" min="1" max="35" step="1" value="1">
        </div>
    </div>

    <div id="infoBox" class="info-box">
        ...
    </div>

    <div class="vis-container" id="visContainer">
        <canvas id="waveCanvas" height="320"></canvas>
        
        <div class="pixel-row-wrapper">
            <div id="pixelRow" class="pixel-row"></div>
        </div>
        
        <div id="hoverMarker"></div>
    </div>

<script>
    // Globális változók
    let currentN = 36;
    let currentK = 1;

    // DOM elemek
    const canvas = document.getElementById('waveCanvas');
    const ctx = canvas.getContext('2d');
    const pixelRow = document.getElementById('pixelRow');
    
    const inputN = document.getElementById('inputN');
    const inputK = document.getElementById('inputK');
    const valN = document.getElementById('valN');
    const valK = document.getElementById('valK');
    
    const infoBox = document.getElementById('infoBox');
    const marker = document.getElementById('hoverMarker');
    const container = document.getElementById('visContainer');

    // Margók a skálákhoz
    const PADDING_LEFT = 40;
    const PADDING_RIGHT = 20;
    const PADDING_TOP = 30;
    const PADDING_BOTTOM = 30;

    let canvasWidth, canvasHeight;
    let graphWidth, graphHeight;
    let cellWidth; 

    // --- 1. Inicializálás: Pixelek létrehozása ---
    function initPixels() {
        pixelRow.innerHTML = ''; // Törlés
        for (let i = 0; i < currentN; i++) {
            const div = document.createElement('div');
            div.className = 'pixel';
            pixelRow.appendChild(div);
        }
    }

    // --- 2. Méretezés ---
    function resize() {
        const rect = container.getBoundingClientRect();
        canvasWidth = rect.width;
        canvasHeight = 320; 
        
        graphWidth = canvasWidth - PADDING_LEFT - PADDING_RIGHT;
        graphHeight = canvasHeight - PADDING_TOP - PADDING_BOTTOM;
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        
        cellWidth = graphWidth / currentN; // Fontos: az új N-el számolunk
        draw();
    }

    // --- 3. Rajzolás ---
    function draw() {
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // X Tengely (Függőleges vonalak)
        // Optimalizáció: Ha N nagy, ne írjunk ki minden számot
        const stepX = currentN > 20 ? 2 : 1; 

        for (let x = 0; x < currentN; x++) {
            const xPos = PADDING_LEFT + x * cellWidth + (cellWidth/2);
            
            // Rács
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(xPos, PADDING_TOP);
            ctx.lineTo(xPos, canvasHeight - PADDING_BOTTOM);
            ctx.stroke();

            // Számok
            ctx.fillStyle = '#666';
            if (x % stepX === 0) { 
                ctx.fillText(x, xPos, PADDING_TOP - 15); 
                ctx.fillText(x, xPos, canvasHeight - PADDING_BOTTOM + 15); 
            }
        }

        // Y Tengely (Vízszintes vonalak - Maradékok)
        // 0-tól N-1-ig
        const yStepCount = Math.min(currentN, 6); // Max 6 osztást rajzoljunk, ne legyen zsúfolt
        const yValueStep = Math.ceil((currentN - 1) / yStepCount);
        
        ctx.textAlign = 'right';
        
        // Segédfüggvény Y pozícióhoz
        const getYPos = (val) => (canvasHeight - PADDING_BOTTOM) - (val / (currentN - 1)) * graphHeight;

        for (let val = 0; val < currentN; val += yValueStep) {
            const yPos = getYPos(val);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath();
            ctx.moveTo(PADDING_LEFT, yPos);
            ctx.lineTo(canvasWidth - PADDING_RIGHT, yPos);
            ctx.stroke();

            ctx.fillStyle = '#00f3ff';
            ctx.fillText(val, PADDING_LEFT - 10, yPos);
        }
        // Felső határ (N-1) mindig legyen kirajzolva
        const topY = getYPos(currentN - 1);
        ctx.fillText(currentN - 1, PADDING_LEFT - 10, topY);

        // Tengely címke
        ctx.save();
        ctx.fillStyle = '#888';
        ctx.textAlign = 'center';
        ctx.translate(15, canvasHeight/2);
        ctx.rotate(-Math.PI/2);
        ctx.fillText("MARADÉK", 0, 0);
        ctx.restore();


        // A HULLÁM
        ctx.beginPath();
        ctx.strokeStyle = '#00f3ff';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'rgba(0, 243, 255, 0.5)';

        const pixels = document.querySelectorAll('.pixel');

        // Fontos: a pixelek listájának hossza most már változik, de az initPixels() kezeli
        // Itt csak biztonsági ellenőrzés
        if (pixels.length !== currentN) return; 

        for (let x = 0; x < currentN; x++) {
            const rawValue = currentK * x;
            const modValue = rawValue % currentN;

            const plotX = PADDING_LEFT + x * cellWidth + (cellWidth / 2);
            const plotY = getYPos(modValue);

            if (x === 0) ctx.moveTo(plotX, plotY);
            else ctx.lineTo(plotX, plotY);
        }
        ctx.stroke();
        ctx.shadowBlur = 0;

        // PÖTTYÖK
        for (let x = 0; x < currentN; x++) {
            const rawValue = currentK * x;
            const modValue = rawValue % currentN;

            const plotX = PADDING_LEFT + x * cellWidth + (cellWidth / 2);
            const plotY = getYPos(modValue);

            ctx.beginPath();
            
            if (modValue === 0) {
                // Találat
                ctx.fillStyle = '#ff00ff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff00ff';
                ctx.arc(plotX, plotY, 5, 0, Math.PI * 2);
                pixels[x].classList.add('active');
            } else {
                // Inaktív
                ctx.fillStyle = '#006064';
                ctx.shadowBlur = 0;
                ctx.arc(plotX, plotY, 3, 0, Math.PI * 2);
                pixels[x].classList.remove('active');
            }
            ctx.fill();
        }
    }

    // --- 4. Interakció ---
    function handleMouseMove(e) {
        const rect = container.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        
        let relativeX = mouseX - PADDING_LEFT;
        if (relativeX < 0) relativeX = 0;
        if (relativeX > graphWidth) relativeX = graphWidth - 1;

        let index = Math.floor(relativeX / cellWidth);
        if (index < 0) index = 0;
        if (index >= currentN) index = currentN - 1;

        const markerPos = PADDING_LEFT + index * cellWidth + cellWidth/2;
        marker.style.left = markerPos + 'px';
        marker.style.display = 'block';

        const raw = currentK * index;
        const mod = raw % currentN;
        const cycles = Math.floor(raw / currentN);

        let html = `<div class="info-text">`;
        html += `Pozíció (x): <span class="highlight-cyan">${index}</span>`;
        html += `<span class="separator">|</span>`;
        html += `Szorzás: ${currentK} × ${index} = <span class="highlight-cyan">${raw}</span>`;
        html += `<span class="separator">|</span>`;
        html += `Moduló: ${raw} / ${currentN} = <b>${cycles}</b> egész, maradék: <span class="highlight">${mod}</span>`;
        
        if (mod === 0) {
            html += ` <span class="highlight">➔ TALÁLAT!</span>`;
        }
        html += `</div>`;

        infoBox.innerHTML = html;
        infoBox.classList.add('visible');
    }

    function updateKRange() {
        // A frekvencia maximuma mindig N-1
        const maxK = Math.max(1, currentN - 1);
        inputK.max = maxK;
        
        // Ha a jelenlegi K nagyobb, mint az új maximum, húzzuk vissza
        if (currentK > maxK) {
            currentK = maxK;
            inputK.value = currentK;
            valK.textContent = currentK;
        }
    }

    // Események
    inputN.addEventListener('input', (e) => {
        currentN = parseInt(e.target.value);
        valN.textContent = currentN;
        updateKRange();
        initPixels(); // Újrageneráljuk a DOM elemeket
        resize();     // Újrarajzoljuk a vásznat
    });

    inputK.addEventListener('input', (e) => {
        currentK = parseInt(e.target.value);
        valK.textContent = currentK;
        draw();
    });

    container.addEventListener('mousemove', handleMouseMove);
    container.addEventListener('mouseleave', () => {
        marker.style.display = 'none';
        infoBox.classList.remove('visible');
    });
    
    window.addEventListener('resize', resize);

    // Start
    updateKRange();
    initPixels();
    setTimeout(resize, 10);

</script>
</body>
</html>