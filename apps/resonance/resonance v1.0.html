<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prime function v1.1</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 24px;
        }

        .controls-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            flex-shrink: 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .global-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        select, input[type="number"] {
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        button {
            padding: 8px 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0056b3;
        }

        .params-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 10px;
        }

        .param-cell {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .param-cell.disabled {
            opacity: 0.6;
            background: #eee;
        }

        .cell-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        .cell-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .input-row {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
        }

        .input-row input[type="number"] {
            width: 100%;
            padding: 2px 4px;
        }
        
        #chart-container {
            flex-grow: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            min-height: 400px;
        }
    </style>
</head>
<body>
    <h1>Prime function v1.1</h1>

    <div class="controls-container">
        <div class="global-controls">
            <div class="control-group">
                <label for="wave-type">Függvény típus:</label>
                <select id="wave-type">
                    <option value="sin">Szinusz (Sine)</option>
                    <option value="cos">Koszinusz (Cosine)</option>
                    <option value="saw">Fűrész (Sawtooth)</option>
                    <option value="ramp">Rámpa (Ramp)</option>
                    <option value="sqr">Négyszög (Square)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="auto-scale" checked>
                    Auto Skála Y
                </label>
            </div>

            <div class="control-group" id="manual-scale-controls" style="display: none;">
                <label for="y-min">Y Min:</label>
                <input type="number" id="y-min" value="-10" style="width: 60px;">
                <label for="y-max">Y Max:</label>
                <input type="number" id="y-max" value="10" style="width: 60px;">
            </div>

            <div class="control-group">
                <label for="global-offset">Y Offszet (+/- 1):</label>
                <input type="number" id="global-offset" value="0" step="0.1" min="-1" max="1" style="width: 60px;">
            </div>

            <div class="control-group">
                <label for="resolution">Felbontás (pont/egység):</label>
                <input type="number" id="resolution" value="36" min="1" max="100">
            </div>

            <div class="control-group">
                <label for="range-max">X Max:</label>
                <input type="number" id="range-max" value="100" min="10" max="100000">
            </div>

            <button id="update-btn">Frissítés</button>
            <button id="reset-btn" style="background-color: #6c757d;">Alaphelyzet</button>
        </div>

        <div id="params-grid" class="params-grid">
            <!-- Grid items will be generated here -->
        </div>
    </div>

    <div id="chart-container"></div>

    <script>
        // State management
        const state = {
            params: Array.from({ length: 100 }, (_, i) => ({
                k: i + 1,
                enabled: i === 0, // Only k=1 enabled by default
                a: 1.0
            })),
            waveType: 'sin',
            globalOffset: 0,
            autoScale: true,
            rangeMax: 100,
            resolution: 36
        };

        // DOM Elements
        const paramsGrid = document.getElementById('params-grid');
        const waveTypeSelect = document.getElementById('wave-type');
        const autoScaleCheckbox = document.getElementById('auto-scale');
        const manualScaleControls = document.getElementById('manual-scale-controls');
        const yMinInput = document.getElementById('y-min');
        const yMaxInput = document.getElementById('y-max');
        const globalOffsetInput = document.getElementById('global-offset');
        const rangeMaxInput = document.getElementById('range-max');
        const resolutionInput = document.getElementById('resolution');
        const updateBtn = document.getElementById('update-btn');
        const resetBtn = document.getElementById('reset-btn');

        // Initialize Grid
        function initGrid() {
            paramsGrid.innerHTML = '';
            state.params.forEach((param, index) => {
                const cell = document.createElement('div');
                cell.className = `param-cell ${param.enabled ? '' : 'disabled'}`;
                cell.dataset.index = index;

                // Header with Checkbox and k value
                const header = document.createElement('div');
                header.className = 'cell-header';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = param.enabled;
                checkbox.addEventListener('change', (e) => {
                    param.enabled = e.target.checked;
                    cell.className = `param-cell ${param.enabled ? '' : 'disabled'}`;
                    requestUpdate();
                });

                const label = document.createElement('span');
                label.textContent = `k = ${param.k}`;

                header.appendChild(checkbox);
                header.appendChild(label);

                // Controls for 'a'
                const controls = document.createElement('div');
                controls.className = 'cell-controls';

                const inputRow = document.createElement('div');
                inputRow.className = 'input-row';

                const aLabel = document.createElement('label');
                aLabel.textContent = 'a:';

                const aInput = document.createElement('input');
                aInput.type = 'number';
                aInput.value = param.a;
                aInput.step = 0.1;
                aInput.min = 0.01;
                aInput.max = 100;
                aInput.addEventListener('change', (e) => {
                    let val = parseFloat(e.target.value);
                    if (val < 0.01) val = 0.01;
                    if (val > 100) val = 100;
                    param.a = val;
                    e.target.value = val;
                    requestUpdate();
                });

                inputRow.appendChild(aLabel);
                inputRow.appendChild(aInput);
                controls.appendChild(inputRow);

                cell.appendChild(header);
                cell.appendChild(controls);
                paramsGrid.appendChild(cell);
            });
        }

        // Calculation Logic
        function calculateData() {
            const xValues = [];
            const yValues = [];
            
            // Calculate step size based on resolution
            // Higher resolution = more points per unit
            const step = 1 / state.resolution;
            const max = state.rangeMax;
            
            // Generate X values
            for (let x = 0; x <= max; x += step) {
                xValues.push(x);
                
                let y = 1;
                let hasActive = false;

                for (const param of state.params) {
                    if (param.enabled) {
                        hasActive = true;
                        
                        // Argument calculation
                        // Note: The original formula was sin(x * pi / k).
                        // Assuming the requirement is to use the same argument structure for other waves.
                        // Wait, original specification said: "a*sin(x*pi*k)"
                        // But previous code had: "Math.sin(x * Math.PI / param.k)" - wait, did I change it to divide?
                        // Let's check my previous thoughts or just stick to the current implementation's logic if it was working.
                        // The user said "5. a tagfüggvények formátuma: +/- a*sin(x*pi*k)." in the first prompt.
                        // But in my last read_file it was `Math.sin(x * Math.PI / param.k)`.
                        // That seems like a bug I introduced or I misread "k" placement.
                        // "x * pi * k" implies frequency increases with k.
                        // "x * pi / k" implies frequency decreases with k.
                        // The user has not complained about this, but I should probably stick to `x * pi * k` as per original spec?
                        // Or maybe I should check why I did `/ k`. 
                        // Actually, looking at the previous file content, it was indeed `/ param.k`.
                        // However, the original prompt said `x*pi*k`. 
                        // I will switch back to `* k` to be safe, or keep it if I think it was intentional.
                        // Let's stick to `x * Math.PI * param.k` which is standard harmonic series behavior.
                        // Wait, actually I will check the file content again. It clearly says `/ param.k` in the text I read.
                        // I will correct it to `* param.k` because usually "harmonics" are multiples.
                        // AND I will implement the other functions.
                        
                        const arg = x * Math.PI * param.k;
                        let rawVal = 0;

                        switch (state.waveType) {
                            case 'sin':
                                rawVal = Math.sin(arg);
                                break;
                            case 'cos':
                                rawVal = Math.cos(arg);
                                break;
                            case 'saw':
                                // Triangle wave: 2 * abs(2 * (t - floor(t + 0.5))) - 1
                                // Period 2PI
                                {
                                    const t = arg / (2 * Math.PI);
                                    // Triangle wave (symmetric rise and fall)
                                    rawVal = 2 * Math.abs(2 * (t - Math.floor(t + 0.5))) - 1;
                                }
                                break;
                            case 'ramp':
                                // Ramp (rising sawtooth)
                                {
                                    const t = arg / (2 * Math.PI);
                                    rawVal = 2 * (t - Math.floor(t + 0.5));
                                }
                                break;
                            case 'sqr':
                                rawVal = Math.sign(Math.sin(arg));
                                break;
                        }
                        
                        // For 'ramp' I used the rising code above.

                        const val = param.a * rawVal;
                        y *= val;
                    }
                }
                
                if (!hasActive) y = 0;
                
                // Add global offset
                y += state.globalOffset;
                
                yValues.push(y);
            }

            return { x: xValues, y: yValues };
        }

        // Chart Rendering
        let plotInitialized = false;

        function updateChart() {
            const data = calculateData();
            
            // Adaptive X-axis ticks
            // Requirement: "amikor 100 vagy kevesebb x érték van megjelenítve az x tengelyen, akkor legyen függőleges osztás minden egész értéknél."
            // This depends on the current view range (zoom level), which Plotly handles via 'relayout'. 
            // However, here we are setting the initial layout or updating data.
            // We can set a default behavior or try to bind it to the range.
            // Since we can't easily react to zoom events inside this simple setup without more complex event binding,
            // we will set the 'dtick' based on the displayed range.
            // Note: Plotly's 'dtick' applies to the view.
            
            // To make it truly adaptive to zoom, we'd need to listen to 'plotly_relayout'.
            // But for now, let's configure it based on the initial state or current manual range?
            // The requirement says "when 100 or less x values are displayed".
            
            const layout = {
                title: 'Szorzat (Product)',
                xaxis: {
                    title: 'x',
                    range: [0, Math.min(100, state.rangeMax)], // Initial zoom
                    rangeslider: { visible: true },
                    // If the initial range is <= 100, force dtick: 1
                    dtick: (Math.min(100, state.rangeMax) <= 100) ? 1 : undefined, 
                    gridcolor: '#eee',
                    zerolinecolor: '#999'
                },
                yaxis: {
                    title: 'y',
                    autorange: state.autoScale,
                    range: state.autoScale ? null : [parseFloat(yMinInput.value), parseFloat(yMaxInput.value)],
                    nticks: 20,
                    gridcolor: '#eee',
                    zerolinecolor: '#999'
                },
                margin: { t: 40, r: 20, l: 40, b: 40 },
                showlegend: false
            };

            const plotData = [{
                x: data.x,
                y: data.y,
                mode: 'lines',
                type: 'scatter',
                line: { width: 1.5 }
            }];

            if (!plotInitialized) {
                Plotly.newPlot('chart-container', plotData, layout, {
                    responsive: true,
                    scrollZoom: true,
                    displayModeBar: true
                });
                plotInitialized = true;
            } else {
                // If autoScale is off, we use manual range
                const updateLayout = {
                    'xaxis.range': [0, state.rangeMax], // Update scrollbar range
                    'yaxis.autorange': state.autoScale,
                    'yaxis.nticks': 20,
                    title: 'Szorzat (Product)'
                };
                
                if (!state.autoScale) {
                    updateLayout['yaxis.range'] = [parseFloat(yMinInput.value), parseFloat(yMaxInput.value)];
                }

                // Merge the new layout properties into the existing layout object for React
                Object.assign(layout, updateLayout);
                layout.yaxis.range = state.autoScale ? null : [parseFloat(yMinInput.value), parseFloat(yMaxInput.value)];
                
                Plotly.react('chart-container', plotData, layout);
            }
        }

        // Event Listeners & Updates
        let updateTimeout;
        function requestUpdate() {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(updateChart, 100); // Debounce
        }

        waveTypeSelect.addEventListener('change', (e) => {
            state.waveType = e.target.value;
            requestUpdate();
        });

        autoScaleCheckbox.addEventListener('change', (e) => {
            state.autoScale = e.target.checked;
            manualScaleControls.style.display = state.autoScale ? 'none' : 'flex';
            requestUpdate();
        });

        yMinInput.addEventListener('change', requestUpdate);
        yMaxInput.addEventListener('change', requestUpdate);
        
        globalOffsetInput.addEventListener('change', (e) => {
            let val = parseFloat(e.target.value);
            if (val < -1) val = -1;
            if (val > 1) val = 1;
            state.globalOffset = val;
            e.target.value = val;
            requestUpdate();
        });

        rangeMaxInput.addEventListener('change', (e) => {
            state.rangeMax = parseInt(e.target.value) || 100;
            requestUpdate();
        });

        resolutionInput.addEventListener('change', (e) => {
            state.resolution = parseInt(e.target.value) || 10;
            requestUpdate();
        });

        updateBtn.addEventListener('click', updateChart);

        resetBtn.addEventListener('click', () => {
            state.params.forEach((p, i) => {
                p.enabled = i === 0;
                p.a = 1.0;
            });
            initGrid();
            requestUpdate();
        });
        
        // Add listener for zoom events to update tick density
        const chartDiv = document.getElementById('chart-container');
        chartDiv.on('plotly_relayout', function(eventdata){
            // Check if x-axis range changed
            if (eventdata['xaxis.range[0]'] !== undefined && eventdata['xaxis.range[1]'] !== undefined) {
                const x0 = eventdata['xaxis.range[0]'];
                const x1 = eventdata['xaxis.range[1]'];
                const diff = x1 - x0;
                
                // Requirement: if <= 100, dtick = 1
                if (diff <= 100) {
                     Plotly.relayout(chartDiv, {'xaxis.dtick': 1});
                } else {
                     Plotly.relayout(chartDiv, {'xaxis.dtick': null}); // auto
                }
            } else if (eventdata['xaxis.autorange'] === true) {
                 // Reset to default check
                 if (state.rangeMax <= 100) {
                     Plotly.relayout(chartDiv, {'xaxis.dtick': 1});
                 } else {
                     Plotly.relayout(chartDiv, {'xaxis.dtick': null});
                 }
            }
        });

        // Init
        initGrid();
        updateChart();

    </script>
</body>
</html>