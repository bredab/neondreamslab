<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prime function v1.1</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 24px;
        }

        .controls-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            flex-shrink: 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        .global-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        select, input[type="number"] {
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        button {
            padding: 8px 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0056b3;
        }

        .params-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 10px;
        }

        .param-cell {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .param-cell.disabled {
            opacity: 0.6;
            background: #eee;
        }

        .cell-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        .cell-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .input-row {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
        }

        .input-row input[type="number"] {
            width: 100%;
            padding: 2px 4px;
        }
        
        #chart-container {
            flex-grow: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            min-height: 400px;
        }
    </style>
</head>
<body>
    <h1>Prime function v1.1</h1>

    <div class="controls-container">
        <div class="global-controls">
            <div class="control-group">
                <label for="wave-type">Függvény típus:</label>
                <select id="wave-type">
                    <option value="sin">Szinusz (Sine)</option>
                    <option value="cos">Koszinusz (Cosine)</option>
                    <option value="saw">Fűrész (Sawtooth)</option>
                    <option value="ramp">Rámpa (Ramp)</option>
                    <option value="sqr">Négyszög (Square)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="auto-scale" checked>
                    Auto Skála Y
                </label>
            </div>

            <div class="control-group" id="manual-scale-controls" style="display: none;">
                <label for="y-min">Y Min:</label>
                <input type="number" id="y-min" value="-10" style="width: 60px;">
                <label for="y-max">Y Max:</label>
                <input type="number" id="y-max" value="10" style="width: 60px;">
            </div>

            <div class="control-group">
                <label for="global-offset">Y Offszet (+/- 1):</label>
                <input type="number" id="global-offset" value="0" step="0.1" min="-1" max="1" style="width: 60px;">
            </div>

            <div class="control-group">
                <label for="resolution">Felbontás (pont/egység):</label>
                <input type="number" id="resolution" value="36" min="1" max="36">
            </div>

            <div class="control-group">
                <label for="range-max">X Max:</label>
                <input type="number" id="range-max" value="30" min="10" max="100000">
            </div>

            <button id="update-btn">Frissítés</button>
            <button id="reset-btn" style="background-color: #6c757d;">Alaphelyzet</button>
        </div>

        <div id="params-grid" class="params-grid">
            <!-- Grid items will be generated here -->
        </div>
    </div>

    <div id="chart-container"></div>

    <script>
        // State management
        const state = {
            params: Array.from({ length: 100 }, (_, i) => ({
                k: i + 1,
                enabled: i === 1, // Only k=2 enabled by default
                a: 1.0
            })),
            waveType: 'sin',
            globalOffset: 0,
            autoScale: true,
            rangeMax: 30,
            resolution: 36
        };

        // DOM Elements
        const paramsGrid = document.getElementById('params-grid');
        const waveTypeSelect = document.getElementById('wave-type');
        const autoScaleCheckbox = document.getElementById('auto-scale');
        const manualScaleControls = document.getElementById('manual-scale-controls');
        const yMinInput = document.getElementById('y-min');
        const yMaxInput = document.getElementById('y-max');
        const globalOffsetInput = document.getElementById('global-offset');
        const rangeMaxInput = document.getElementById('range-max');
        const resolutionInput = document.getElementById('resolution');
        const updateBtn = document.getElementById('update-btn');
        const resetBtn = document.getElementById('reset-btn');

        // Initialize Grid
        function initGrid() {
            paramsGrid.innerHTML = '';
            state.params.forEach((param, index) => {
                const cell = document.createElement('div');
                cell.className = `param-cell ${param.enabled ? '' : 'disabled'}`;
                cell.dataset.index = index;

                // Header with Checkbox and k value
                const header = document.createElement('div');
                header.className = 'cell-header';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = param.enabled;
                checkbox.addEventListener('change', (e) => {
                    param.enabled = e.target.checked;
                    cell.className = `param-cell ${param.enabled ? '' : 'disabled'}`;
                    requestUpdate();
                });

                const label = document.createElement('span');
                label.textContent = `k = ${param.k}`;

                header.appendChild(checkbox);
                header.appendChild(label);

                // Controls for 'a'
                const controls = document.createElement('div');
                controls.className = 'cell-controls';

                const inputRow = document.createElement('div');
                inputRow.className = 'input-row';

                const aLabel = document.createElement('label');
                aLabel.textContent = 'a:';

                const aInput = document.createElement('input');
                aInput.type = 'number';
                aInput.value = param.a;
                aInput.step = 0.1;
                aInput.min = 0.01;
                aInput.max = 100;
                aInput.addEventListener('change', (e) => {
                    let val = parseFloat(e.target.value);
                    if (val < 0.01) val = 0.01;
                    if (val > 100) val = 100;
                    param.a = val;
                    e.target.value = val;
                    requestUpdate();
                });

                inputRow.appendChild(aLabel);
                inputRow.appendChild(aInput);
                controls.appendChild(inputRow);

                cell.appendChild(header);
                cell.appendChild(controls);
                paramsGrid.appendChild(cell);
            });
        }

        // Calculation Logic
        function calculateData() {
            const xValues = [];
            const yValues = [];
            
            // Calculate step size based on resolution
            // Higher resolution = more points per unit
            const step = 1 / state.resolution;
            const max = state.rangeMax;
            
            // Generate X values
            for (let x = 0; x <= max; x += step) {
                xValues.push(x);
                
                let y = 1;
                let hasActive = false;

                for (const param of state.params) {
                    if (param.enabled) {
                        hasActive = true;
                        
                        
                        const arg = x * Math.PI / param.k;
                        let rawVal = 0;

                        switch (state.waveType) {
                            case 'sin':
                                rawVal = Math.sin(arg);
                                break;
                            case 'cos':
                                rawVal = Math.cos(arg);
                                break;
                            case 'saw':
                                // Triangle wave: 2 * abs(2 * (t - floor(t + 0.5))) - 1
                                // Period 2PI
                                {
                                    // Shifted by -0.25 to start at 0 (sine-like phase)
                                    const t = arg / (2 * Math.PI) - 0.25;
                                    // Triangle wave (symmetric rise and fall)
                                    rawVal = - 2 * Math.abs(2 * (t - Math.floor(t + 0.5))) + 1;
                                }
                                break;
                            case 'ramp':
                                // Ramp (rising sawtooth)
                                {
                                    const t = arg / (2 * Math.PI);
                                    rawVal = 2 * (t - Math.floor(t + 0.5));
                                }
                                break;
                            case 'sqr':
                                rawVal = Math.sign(Math.sin(arg));
                                break;
                        }
                        
                        // For 'ramp' I used the rising code above.

                        const val = param.a * (rawVal + state.globalOffset);
                        y *= val;
                    }
                }
                
                if (!hasActive) y = 0;
                
                yValues.push(y);
            }

            return { x: xValues, y: yValues };
        }

        // Chart Rendering
        let plotInitialized = false;

        function updateChart() {
            const data = calculateData();
            
           
            const layout = {
                title: 'Szorzat (Product)',
                xaxis: {
                    title: 'x',
                    range: [0, Math.min(100, state.rangeMax)], // Initial zoom
                    rangeslider: { visible: true },
                    // If the initial range is <= 100, force dtick: 1
                    dtick: (Math.min(100, state.rangeMax) <= 100) ? 1 : undefined, 
                    gridcolor: '#eee',
                    zerolinecolor: '#999'
                },
                yaxis: {
                    title: 'y',
                    autorange: state.autoScale,
                    range: state.autoScale ? null : [parseFloat(yMinInput.value), parseFloat(yMaxInput.value)],
                    nticks: 20,
                    gridcolor: '#eee',
                    zerolinecolor: '#999'
                },
                margin: { t: 40, r: 20, l: 40, b: 40 },
                showlegend: false
            };

            const plotData = [{
                x: data.x,
                y: data.y,
                mode: 'lines',
                type: 'scatter',
                line: { width: 1.5 }
            }];

            if (!plotInitialized) {
                Plotly.newPlot('chart-container', plotData, layout, {
                    responsive: true,
                    scrollZoom: true,
                    displayModeBar: true
                }).then(attachZoomListener);
                plotInitialized = true;
            } else {
                // Determine current range to preserve zoom
                const chartDiv = document.getElementById('chart-container');
                let currentXRange = null;
                if (chartDiv.layout && chartDiv.layout.xaxis && chartDiv.layout.xaxis.range) {
                    currentXRange = chartDiv.layout.xaxis.range;
                }

                // If autoScale is off, we use manual range
                const updateLayout = {
                    'yaxis.autorange': state.autoScale,
                    'yaxis.nticks': 20,
                    title: 'Szorzat (Product)'
                };
                
                // Only update xaxis range if max range changed significantly or never set?
                // Actually, Plotly React handles updates. If we don't supply xaxis.range, it might keep it or autorange.
                // But we want to preserve the *current* zoom.
                if (currentXRange) {
                    updateLayout['xaxis.range'] = currentXRange;
                } else {
                    updateLayout['xaxis.range'] = [0, Math.min(100, state.rangeMax)];
                }
                
                // Update slider range
                updateLayout['xaxis.rangeslider'] = { range: [0, state.rangeMax] };

                if (!state.autoScale) {
                    updateLayout['yaxis.range'] = [parseFloat(yMinInput.value), parseFloat(yMaxInput.value)];
                } else {
                    // Adaptive Y-Zoom logic
                    // If auto-scale is ON, we want to scale to the VISIBLE data.
                    // But 'autorange: true' scales to ALL data.
                    // We need to calculate the Y range for the current X range.
                    if (currentXRange) {
                        const xMin = currentXRange[0];
                        const xMax = currentXRange[1];
                        
                        // Filter data
                        let localMin = Infinity;
                        let localMax = -Infinity;
                        let hasPoints = false;

                        for(let i=0; i<data.x.length; i++) {
                            if (data.x[i] >= xMin && data.x[i] <= xMax) {
                                if (data.y[i] < localMin) localMin = data.y[i];
                                if (data.y[i] > localMax) localMax = data.y[i];
                                hasPoints = true;
                            }
                        }
                        
                        if (hasPoints) {
                            // Add some padding (e.g. 5%)
                            const span = localMax - localMin;
                            const padding = span === 0 ? 1 : span * 0.05;
                            updateLayout['yaxis.range'] = [localMin - padding, localMax + padding];
                            updateLayout['yaxis.autorange'] = false; // We set manual range dynamically
                        }
                    }
                }

                // Merge the new layout properties into the existing layout object for React
                Object.assign(layout, updateLayout);
                
                Plotly.react('chart-container', plotData, layout);
            }
        }

        // Event Listeners & Updates
        let updateTimeout;
        function requestUpdate() {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(updateChart, 100); // Debounce
        }

        waveTypeSelect.addEventListener('change', (e) => {
            state.waveType = e.target.value;
            requestUpdate();
        });

        autoScaleCheckbox.addEventListener('change', (e) => {
            state.autoScale = e.target.checked;
            manualScaleControls.style.display = state.autoScale ? 'none' : 'flex';
            requestUpdate();
        });

        yMinInput.addEventListener('change', requestUpdate);
        yMaxInput.addEventListener('change', requestUpdate);
        
        globalOffsetInput.addEventListener('change', (e) => {
            let val = parseFloat(e.target.value);
            if (val < -1) val = -1;
            if (val > 1) val = 1;
            state.globalOffset = val;
            e.target.value = val;
            requestUpdate();
        });

        rangeMaxInput.addEventListener('change', (e) => {
            state.rangeMax = parseInt(e.target.value) || 100;
            requestUpdate();
        });

        resolutionInput.addEventListener('change', (e) => {
            state.resolution = parseInt(e.target.value) || 10;
            requestUpdate();
        });

        updateBtn.addEventListener('click', updateChart);

        resetBtn.addEventListener('click', () => {
            state.params.forEach((p, i) => {
                p.enabled = i === 0;
                p.a = 1.0;
            });
            initGrid();
            requestUpdate();
        });
        
        // Add listener for zoom events to update tick density
        const chartDiv = document.getElementById('chart-container');
        
        function attachZoomListener() {
            chartDiv.on('plotly_relayout', function(eventdata){
                let update = {};
                let x0, x1;
                let xRangeChanged = false;

                // Handle different ways Plotly reports range changes
                if (eventdata['xaxis.range[0]'] !== undefined && eventdata['xaxis.range[1]'] !== undefined) {
                    x0 = eventdata['xaxis.range[0]'];
                    x1 = eventdata['xaxis.range[1]'];
                    xRangeChanged = true;
                } else if (eventdata['xaxis.range'] && eventdata['xaxis.range'].length === 2) {
                     x0 = eventdata['xaxis.range'][0];
                     x1 = eventdata['xaxis.range'][1];
                     xRangeChanged = true;
                }

                if (xRangeChanged) {
                    const diff = x1 - x0;
                    
                    // Requirement 1: if <= 100, dtick = 1
                    if (diff <= 100) {
                        update['xaxis.dtick'] = 1;
                    } else {
                        update['xaxis.dtick'] = null; // auto
                    }

                    // Requirement 2: Adaptive Y Zoom
                    if (state.autoScale) {
                        // Access data from the plot
                        const plotData = chartDiv.data[0];
                        let localMin = Infinity;
                        let localMax = -Infinity;
                        let hasPoints = false;
                        
                        // Optimize loop?
                        for(let i=0; i<plotData.x.length; i++) {
                             const xv = plotData.x[i];
                             if (xv >= x0 && xv <= x1) {
                                 const yv = plotData.y[i];
                                 if (yv < localMin) localMin = yv;
                                 if (yv > localMax) localMax = yv;
                                 hasPoints = true;
                             }
                        }
                        
                        if (hasPoints) {
                            const span = localMax - localMin;
                            const padding = span === 0 ? 1 : span * 0.05;
                            update['yaxis.range'] = [localMin - padding, localMax + padding];
                            update['yaxis.autorange'] = false;
                        }
                    }
                } else if (eventdata['xaxis.autorange'] === true) {
                     // Reset to default check
                     if (state.rangeMax <= 100) {
                         update['xaxis.dtick'] = 1;
                     } else {
                         update['xaxis.dtick'] = null;
                     }
                     if (state.autoScale) {
                         update['yaxis.autorange'] = true;
                     }
                }

                // Apply update if we have keys
                if (Object.keys(update).length > 0) {
                    Plotly.relayout(chartDiv, update);
                }
            });
        }

        // Init
        initGrid();
        updateChart();

    </script>
</body>
</html>